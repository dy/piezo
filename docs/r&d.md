## [x] name -> piezo

  * auriel, aureil, aury
    + available
    + refers to arch-angel
    + patron of arts
    + starts with "au" for "audio"
    + ends with "l" for "language"
    + "aurum" means gold
    ~ aural, aurum, auriel, aurea, aurel
    - too biblical
    - too long
    + .au extension
    + AUdio REInterpretation Language
    + ...from auriel
  * auro
    + auro- as prefix, like mono-auro-phonic, auro-scope, auro-palp...
      + see https://en.wiktionary.org/wiki/auro-
    + slight reference to Gaura
    + lino, mono, auriel, aura, aural
    + auro-bindo (red lotus), auro-ville
    + auro - God of Gold, golden
    + .au, .a, .auro
      ? auro.
    + AUdio ROsette üéßüèµÔ∏è
      ~ not as meaningful
    +~ AUdio pROcessing
    ~- not distinguished enough
    ~- binds to audio field only
    ~+ auro.noise, noise.auro
    - spiritless: I have less motivation to finish it
  * audr
    + compatible with sonr
  * aux
    - taken, but so many names are taken anyways
    + reminds audio directly
    + 3 letters
    + refers to auro
    + consequence from line-in
    - conflicts with auxlang https://en.wikipedia.org/wiki/International_auxiliary_language
    - reminds mux, which it is not
    + au-dio [processing,synthesis,analysis]
      ~- can be not just audio
    + asm -> ausm -> aux
  * adya
    + short from audio
    + "now" in sanskrit
  * auda, audo
    + free
    + refers to audio
    + refers to gauda
    + oda in russian
  * audya, audia, audiya
    + gaudiya (math)
    + audio
    + adya = "now"
  * audy
    + au dy
    - `.aud` is australian dollar
  * audie
    + name
  * audx
  * auss
  * auzio
  * acoust, acoustica, acoustical

  * bandpass
  * beato
  * beat, baet, beaut, bitr
    + kick.beat
  * beatr, beatl, bitl
  * beatok
  * beepbop

  * chor, choir
  * cyntia, synthia
  * coo-coo
    + sound
  * coustic
  * cyme, cyma, cymo
    + cymatics

  * deci
  * dizz

  * diau, dioau
    + play on au-di, like diaudiaudiau
    + Sercy likes that sound
    + di in naming (my initials)
  * dyau
    + dy
    + audy
    + adya
    + gaudiya

  * echo
  * essay
  * etude

  * fuzz, buzz, hizz
  * fono
    - kick.fon,

  * gaur, gauro, gour
    + free
    + gauranga - reference to Holiest person
      ~ too saintly reference, to the point of forgetting the language
    + golden
  * gauri, gauda
    - clashes with gaudi
    - will clash with gaudi script below
  * gaudi, gaudy
    + gaudi script
    - taken
  * gaudio
    + audio + gaudia
  * gita

  * gauzz, gauz
  * gramo

  * hear

  * ilang
    + alternative prononciation of ylang-ylang
    + iPhone, iLang
      - cheesy
    + ivanov lang
    + npm is free
    + kirtan.i, mono.i, sobel.i, viznut.i, predestined-fate.i

  * lila
    + sanskrit for "play"

  * line noise (lino)
    - npm is taken and dispute is hard
      ? redirect to `@audio-lab/lino`?
    + sonlang can be more generic than just sound: any linear signals
    + looks like line noise
      + `linoify` = line noisify
    + produces line noise
    + matches `mono`
    + lino is beginning of "linotype"
    - good thing (for God) cannot be called bad words...
      ~+ irony? God doesn't need things
    - `.son` extension is missing
      + `.lin` extension is pretty cool too, like flax
    - `.lin` vs `.ln` vs `.li` vs `.lino`, `.l`
    + it's more generic than sound
  * lisa
    ~+ like lino
    + mono -> lisa
    + reminds Julia lang
    + file can be named literally mono.lisa
    - already exists: https://github.com/Somainer/lisa-lang
    - super-confusable
  * lyno
    + free
    + alliteration to lino
  * loni, lony
  * looney
    + looney tunes

  * mell
    + melody language
    + bell
    + mell tunes
    + .mel .me
    + mellifluous (sweet-sounding)
  * mela
    + melody language
    + metronome language
    - .mela
      + kirtan.mela
        - source.mela is meaningless as "congregation"
    + sanskrit for "tune"
    + ChatGPT recommends it as unique name
    - it means gathering, has nothing to do with melodies, there's a bunch of non-kirtan melas
  * mel
    + short
    + in-line with other 3-letter langs
    + extension .mel matches language name
    + mel scale
    - too programming / physycal / dry
  * ~~melo~~
    + short from melody
    + alliterates to mono
    + dy/melo
    - not clear extension
    - 4 letters
    - https://github.com/mistodon/melo
  * medl
  * melism
  * melophone

  * noli
    + reverse lino
    + noli in russian
  * naad
    + cosmic sound
    - .nd? .naad?
    + free
    - hindoo
  * niva
    + anagram to ivan-ov
    + anagram to vina
    + anagram to vani
    + anagram to navi (ocean)
    ~ residence, abode
    ~ .n
  * nowr
    + sonr, latr
    + iva-now
    - `now` is taken by vercel

  * onna, ona, oha

  * patchr
  * phono
  * phaso, phasae, phas
    + free
    + more generic than just sound
  * piezo
    + refers to electricity
    + refers to audio / signals / recording
    + refers to low-level
    + refers to zz
    + `.z` or `.zz` extension
    + indirectly relates to language (direct is boring)
    + piezo-language
      + there's so much of piezo-, but not language
    + –ø–∏—à—É –Ω–∞ –ø—å–µ–∑–µ sounds cool

  * raev
    + —Ä—ë–≤

  * soufn, sofn, sofun, so-fun, funzo, zfun
  * sound-fu, zound-fu, zo-fu, sonfu, sone-fu
  * sonnes, sonn, sounes
    + is sonnes (sounds in french), sones, sonne in German
  * sonra, sondra
    + feminine
    + ra sound (Radha)
    + mystical aspect, like spect
  * sono
    - close to suno
  * sond, sondr, sounder? sounr? soonr?
  * sonl? sonal?
    + sona language
    + soun
  * sond?
  * sone, sones, sonx, sounx, sonez, sonz, sounz
    + sone-script (sonscript)
    + unit of sound measurement
    + synth.s, synth.sone
      + both signal and sound
    + doesn't attach to audio as much: can be signals also
    + like .tone but .sone - more about signals/noises
    + legacy own name
      - smells old
  * ~~sone / sonescript~~ -> donated
    + like sanskrit
    + sound script
    + son is common root for sound
    + (sonata, song, sone, )
    + .son extension is ok: reverb.son
    + sanskrit (lamish but ok teaches humbleness)
    + le son
    + sonr naturally grows as IDE
    - son is confusing with a person
    - weak association with sound
      +~ same as other options
    ~ script has association with javascript, or roots from that (assemblyscript etc) - to mind that point.
    ‚Üí if we root from assembly, it has more sense to call sont

  * soneslang?
  * solo? solr? soloscript? solos?
    - taken
    + like mono
    + viznut.solo
    + –∑–∞–ø–∏–ª–∏—Ç—å —Å–æ–ª–æ
    - not unique enough
  * sola
    + sound language
    + sol la
    + viola, triola, sola
    - not colloquial
  * sound-fun
    + like "sounds fun" phrase.
  * sonf?
    + sound-functions
    + sound-fun
    + sound-formulas
    + sound-fu
  * sonr?
    . maybe we should just keep name: it is short, clear, keeps .son files, playground
  * soun
    + short from sound
    + abbreviation for sone
    +~ soul
    +~ sone
    +~ sour
  * synl
  * syne
    + sine modified - cooler than sine
    + sync
    + `.s`, `.sy` is cool
    + sone without o
    + synth
    + mentions y from yv
    + sinelang is cool
    + syntax
    + shinto
    - zyne lang is there
    - too similar to "sane" - cannot publish
  * synto
  * sinu
  * sino
    + sine
    + signal-noise
    + si/no (spanish)
    + lino
  * sinusoid
  * sina
  * soid
  * souno
  * sen
  * symph
    + symphony
    + more personal
  * symf
  * sizz
    + swizz
    + noise kind
    + zz
    + sister (Sercy)
  * swyz
  * swist
  * shym
    + shyam
    + noise
    + Sneezed
    + legacy from lino
    - reminds sham, shim
  * shum
  * suri
    + name of Krishna
    + wisdom
  * shruti, sruti
    + that which is heard
    + reference to vedas
    + sruti-lang
    + cryptic
    + factually floatbeats are what sruti-box is doing
    + sruti.box for collection of floatbeats
    - @shruti/@sruti org is taken
    - has too strong Indian sense
      -? web-audio build on sruti
    - —Å—Ä—É—Ç–∏
    - shruti or sruti - confusion
  * sonarm
    + tonarm + sone
  * sonant
  * sonophone
  * sonat
  * syntone, sinton, synton, syntonic
  * sonm, solm
  * sonant, sonorant
  * sounio
  * sousound, sousoun
    + —Å—É—Å–æ–Ω—è
  * soun
  * subsound
  * subwoofer
  * subharmonic
  * subtonic
  * subsonic
  * soge
    + sound gen
  * sige
    + signal generator
    + signal
    - not just generator, must be analysis, synthesis, processing
  * syg
    + signal
    - zig lang

  * timbr
  * tinnitus, tinnit
    + tin - nit
    + ringing when no sound present
  * tonr, tonl
  * tonar, tonae, toneau, tonau
    + bureao
  * tonarm, tonearm
    + t for time
    + .t extension can refer to t argument
    + sound term
    - taken for unknown person
  * tonx
    + tones
    + tonics
  * tons
  * tone
  * tona
  * tono
    + lino, mono(-tono)
    + `kick.ton`, `clap.ton` is _cool_
    + noto-
    - no strong feelings
    - associates with Antony, which
  * tuno
  * tuni
  * tych, tycho, tiho
  * tonic
  * tonae
    + free
    + tone, sprae
  * tonola
  * tonophone

  * utone, uton
  * uphone
  * undertone
  * ubertone
  * unsweep
    + unidentified sound

  * veena
    + narada's playing instrument
    + free
  * vina
    - taken
    + anagram to ivan(ov), like
  * vyna
  * vani
    + speech, sound, voice in sanskrit
    + associated with Saraswati - goddess of arts, music, knowledge, speech.
    + anagram to ivan(ov)
    - taken as v-ani! Heck!
  * vibr

  * wyzg
  * waev

  * ylang
    + ylang-ylang
    + yvanov lang
    - two ylangs in history
    - npm is taken (by chinese)
    + yyfx
    + kirtan.y, mono.y, sobel.y, viznut.y, predestined-fate.y
      + source.y

  * z
    + zlang - zound/zvuk lang
    + zzfx
    - z language, z++ language exist
  * zz
  * zvyk
  * zwk
    + free
    + 3-letter
    + russian "sound"
    + starts with z
  * zwn
  * zwch
    * zoid
  * zynt
  * zound
    - everything with Z is now war-related
    - headplugs

### [x] Name matrix

  * Prefix: syno, zylo, auro, mono, phono, tono, melo, micro, nano, pano, peri, neo, chrono, ambi, duro, uber/ober
  * Postfix: -on, -ona, -l, -la, -al, -ala, -ula, -ela, -lo, -lu, -r, -a, -ar, -er, -ara, -or, -ora, -e, -ea, -ae, -oa, -oe, -ue, -ee, -eau, -eon, -eo, -iou, -o, -ou, -au, -ieu, -q, -y, -ya, -ay, -aya, -ey, -ant, -ata, -ine, -ism, -um, -ium, -us, -ify, -ory, -esque, -ique, -quoe, -quai, -oid, -ure, -ance, -ence, -iq, -ix, -ys, -yn, -ux, -yr, -io, -is, -os, -yre
    * Vowels: aa, ae, ai, ao, au, ay, ea, ee, ei, eo, eu, ey, ia, ie, ii, io, iu, iy, oa, oe, oi, oo, ou, oy, ua, ue, ui, uo, uu, uy, ya, ye, yi, yo, yu, yy
  * Ligatures: ae, oe, fi, fl, ff
  * Doubles: sonne, tonne, mello, synn, fuzz, wuzz
    * Consonant: bb, cc, dd, ff, gg, hh, jj, kk, ll, mm, nn, pp, qq, rr, ss, tt, vv, xx, zz
      * Pairs: bl, bp, br, ch, ck, cl, cr, dr, dt, fl, fr, fv, gk, gl, lb, lm, mb, mn, nm, pl, pr, rl, sc, scr, sh, shr, sk, sl, sm, sn, sp, spl, spr, st, str, sw, sz, th, thw, tr, ts, tw, wh, wr, wv.
  * Alliterations: fuzzy-wuzzy, susi-musi, sus-wus
  * Transformations: noise -> noiz, sine -> syne
    * Vowels: o -> au/ou -> aou/eau -> oeau, e -> oe/ea -> eau, i/y -> yi, ay - aie - aye- ae

### [x] Compiler: Should it compile to wat or to wasm? ‚Üí wat for now

  - wasm is faster
  - wasm allows web compilation: doesn't require heavy wabt dependency
  - wasm is "true" direct way
  - wasm is something new to learn
  + wat allows wat2wasm compiler optimizations
    ~ can be done via wasm too
  + wat allows debugging, bytecode can be hardstone
    ~- wasm2wat also allows debugging
      ~+ still reverse compilation can lose variable/function names
  + wat can be done via wat-compiler and other better fit for that mappers
    - wat-compiler is stale and unlikely to improve

  * ? Can be both I suppose, but needs researching wasm format - mb we can utilize fn tables in better way

### [x] Compiler: targets ‚Üí WAT

  * WASM
  * WAT
    + replaceable with wabt, wat-compiler
    + generates wat file as alternative to wasm
    + easier debugging
    + natural and easier code than array structs
  * JS
    + can be useful in debugging
    + can useful in direct (simple) JS processing
    + can be useful for benchmarking
  * Native bytecode
  * others?

## [ ] Variables: Standard channel names `a.lr`, `a.xyzw` -> likely no: very little value over swap

  + like glsl (data views to underlying block buffer), with [standard channel ids](https://en.wikipedia.org/wiki/Surround_sound#Standard_speaker_channels); swizzles as `a.l, a.r = a.r, a.l; a.fl, a.fr = a.fl`
  - conflicts with no-keyword principle, eg. would be inconsistent to `–∑–≤—É–∫.lr = –∑–≤—É–∫.rl`
  - conflicts with internal vars access `sound.t = 0`

  * ALT: `a.01 = a.10`
    - `a[0,1]=a[1,0]`

## [x] Functions: signature -> `f(x, y) = x + y`

  1. `f(x, y) = x + y`
    + standard classic way to define function in math
    + also as in F# or Elixir
    - conflicts with anonymous fn notation

  2. ~~[x] `f(x,y) -> x + y`~~
    + looks very similar
    + also classic-ish function notation
    + natural extension of lambda functions
    + unifies lambda functions look
    + organically permits lambda functions
    - conflicts with mapper/transform
    - lambdas require dynamic fn context allocation, which is not worth it

  3. `f = (x,y) -> x + y`~~
    + all pros of prev
    + JS-familiar notation
    + less fancy syntax extensions
    + better indicator of fn primitive
    ? batch output: `~() -> 1` vs `() -> ~1` vs `() ~> 1`

## [x] Enums ‚Üí try avoiding explicit notation

  * ? for enums and ranges `{a,b,c}` seems to be the best:
    ref: https://en.wikipedia.org/wiki/Enumerated_type#Syntax_in_several_programming_languages
    + doesn't associate with arrays / props if brackets were `[]`
    + associate with regex ranges
    + classic math ranges
    + [set-buider notation](https://en.wikipedia.org/wiki/Set-builder_notation)
    + both ranges and enums
    + used in may languages
    - a bit redundant for range definition as `{0..10}`: `{}` has js intuition as creating/destructuring object.
    - holds "scope" or "object" meaning
      ~ nope: we decided to free `{}` from scope meaning. And object === set, so.
    ‚Üí sets can be listed as `(a,b,c)` ()
      ‚áí or even better, as functional languages do: `type in a|b|c`

## [x] Strings: -> useful for floatbeats, use `""` notation

  * Erlang-like "hello" === [104,101,108,108,111]
    + Standard
    + F#-compatible
    + `"` is not used for apostropes, so no need for `'`
    + `'` can be used for atoms (later)
  - Case-sensitivize code
  + Floatbeats use strings
  + Static precompiler can convert static arrays to strings
    - not really, it converts them to data sections, which is not string
  + Map directly to data
  - convert to arrays
  - `string + string` is pointless
  - many overloaded ops is impossible to implement
  - `\\ab\\bc` in wat is same as `[0xab,0xbc]`
  - not clear how to maintain uint8 array, since it is what string creates. Implementation complexity

  ALT: can we introduce alternative syntax for HEX/data?
    * `{0xabaababa13241abbabaabbabab123451236546389}` or something like

### [ ] Strings: String is array of uint8, but piezo supports only f64 numbers. How to read as u8s? ->

  1. discard uint8 and just do f64 instead?
    ~ since strings are static, we at-part know what type it has.
      - it can be fn argument
    + the fastest way
    - non-compact memory to store value, 8x overkill, even for i32
    - returned UInt8Array doesn't contain string, needs Float64Array
      ~ not hard to convert
      ~ we wouldnt' likely do utf-8 anyways
    + allows easier unicodes store, up to u16
      + a bit like utf 32
      + in other words, it's consistent-size store, which simplifies calculation / indexing / shift

  2. We can write type info into array data: we don't need i32 array addresses.
    + allows uint8 arrays
    + we need just 1 bit for that info
    -~ slows down array access/write a bit
      - can be a trouble reading large amounts of arrays
    -~ enables types via data
    -~ no obvious location for such bit: screws up address

  3. String is sequence, not array
    + `["abcdef"]` - to create an array - visually more apparent
    + allows uint8's
    ~- limited to stack of 1000 elements
      + it's not a good practice anyways to have long strings
    ~ at least good optimization technique
    ~- not clear how to save string into a variable, unless we make groups saveable items

  4. String must be ints, i32 array
    + CharCodes are never floats, so it's logical to have both int/float
    + Allows better JS interop, no custom transforms
    ? how to flag that list is u32?
      ~ suppose we store array length in bytes, not in members
      a. last bit indicates even/odd number for length, we can use it as indicator of f64/i32 array, and store length in bytes (cross-op for f64/i32)
        - complicates calc a bit - we'd need to read that flag and shift depending on it
        - limits available types to one flag
      b. store few bits for data type, eg. up to 16 types
        + there's 14 ways to read memory: https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/Memory/Load, f24 is coming
      c. store stride
        - doesn't help making sense which type to read from memory

## [x] !? atoms: 'hello' (not string) -> no, until needed
  * Atoms are useful for referencing:
    + function instances
      ~ we have funcref type, not necessary
    + ranges?
    + arrays
    + file paths
  * ? we can use i64 for them
  * ? or we can use f64 for all numbers by default and keep rest of types free
  + ok, can be useful for special syntax with non-string meaning, like paths, dates and other atoms.
  + also can be used for special name variables maybe? like `'x-1' = 2; x0; x1;`
    ? or use `x\-1 = 2` instead?
    - nah, very confusing
  ! We can reserve atoms for import directives.
  + can be useful for throwing expressions

## [ ] Strings: interpolation -> likely `"a $<b> c"`

  1. `"a {b} c"`
  2. `"a $<b> c"`
    + matches includes signature `<math#x,y>`
    + matches JS regex signature
    + `<>` means insert something here

## [ ] Strings: string operations - concat, split, join etc

  ~ likely via stdlib
  * `a ++ b` for concat, `"abc" ++ "def";`
    + zlang/purescript/etc - compatible
    * `a -- b` for split?
      * `"abc:def" -- ":"`
  * ~~`a <> b` for concat, `"abc" <> "def"`~~
    * `a >< b` for split, `"abc:def" >< ":"`
  * `"ab:cd" :- ":"` for split
    * `"ab", "cd" :+ ":"` for join
    * `a :: b` for concat, `"abc" :: "def"`
  * `a // b`, `"ab:cd" // ":"` for split would be better
  !? make concat and join a single operator
    * `a <:> b`, eg `"abc" <:> "def"`
  * `"abc$<def>"` for concat
  * `"ab", "cd" |> # ++ ":" ++ _` for join
    * `"ab:cd:ef" |> _ === ":"`

## [x] Numbers: float64 by default, unless it's statically inferrable as int32, like ++, +-1 etc ops only
  * Boolean operators turn float64 into int64

## [x] Pipes / Loops: ~~‚Üí | with anon functions~~ ~~transform ternary `list | x -> a(x) | x -> b(x)`~~ pipes are loops `x |> _ * 0.6 + reverb(_) * 0.4 |> `

  1. Placeholder as `x | #*0.6 + reverb() * 0.4`, `source | lp($, frq, Q)`?
    ? can there be multiple args to pipe operator? `a,b |` runs 2 pipes, not multiarg.
    ? possibly it should be both: passing input as `input` implicit param, `#` redirects to another param
      - nah, too complicated.
    - function plays natural role of args inserter, why duplicating with topic placeholder?
      ~+ function creates a (semantic) scope, whereas pipe acts on the same level
    ‚Üí ok, seems like intuition for `|` is direct expression, sort of overload: `a | filter(f, q)` ‚Üê filter creates fn here
    ‚Üí but for pipeline there's intuition as `a |> filter(#, f, q)` ‚Üê we don't necessarily need that
    + $ looks regexy - backreferences in both string/regexes
    - implicit/reserved references we could avoid
    + it's overall shorter than other options, as easy syntax sugar, because
      * `a | a -> a+1` introduces fn overload overuse and curried fns constructor problem
      * `A()=a->a+1; a | A()` requires heavy constructor code and passing lambdas
      * `a |> a -> a+1` is redundancy and aint nice looking
    ? enable access to group members as `a,b,c | d($1, $2)`
    - sending group items would require referencing by number
      ~ unless we prohibit sending groups, not sure we need it.

  1.1 What if we get rid of pipe operator and just use "last expression" placeholder?
    * `a; ^ + 1;`
    + clean, compact
    + caret character literally defines as "insertion point"
    + wikipedia uses ^ for referencing
    + comes well with "last expression result" logic.
    - doesn't allow easy use in initializer
      ~+ unless we do ...a=(x;^+y)
    + applies to group naturally
      ~+ ...a=(x1,x2,x3;^+y) - does it apply to sequence?
        ~ yes, to get n-th member do ^[0] or ^.0
        ~ semic is noisy here.
    -~ doesn't make much difference with just ...a=(tmp=x;tmp=tmp+y), only shorter
    ~ can possibly do `^2`, `^3` in wasm-style access to stack variables
    - enforces redundant parens, `...a=(x;^+y)` compared to `...a=x|>add(y)`
      + as mitigation see 3.1
    - can't go as single fn argument a(b; c(^, d)) vs a(b | c(d))

  2. ~~Pass first argument[s] to pipe operator (elixir/R-like): `source |> lp(frq, Q)`?~~
    + That would be just direct R/elixir pipes.
    * a,b,c |> fn() - maps multiple, (a,b,c) |> fn() - maps single
    + `||>` to send all arguments to inputs `a,b,c ||> mix()` === `mix(a,b,c)`
      * whereas `a,b,c |> mix()` === `mix(a),mix(b),mix(c)`
        ? can't we just `mix(a,b,c)` or `mix(..abc)`?
      ? what if we send pairwise, depending on mixer target args length? `a,b,c ||> sum()` === `sum(sum(a,b), c)`
        + this way we can implement any sort of reducers
    + |> can have other than | precedence
    + available instantly to all functions, not only overloaded ones
    + puts chunks into separate functions = good [musical] practice
      + makes code easier to read
    + plays well with >- operator in fn signature a,b,c|>fn()>-sum()
    + compact
    + replaces lambda in a way (see reverb case)
    - Operator `|>` makes assumption about next call operator `a()` - what if there is `a |> b` - how's that applied?
      - this and >- make it confusing if that's supposed to pass funcref `a |> b` or call to a function `a |> b()`
      - this makes lino less strict, more toyful script, because it doesn't stand exhaustive review
    - missing an easy way to insert placeholder value, forcing 1-time fn defs or lambdas.
      ? topical pipe `source .> sign(.) * abs(.) ** shapeCurve`? - nah, indecisiveness.
    - aesthetically |> doesn't match -< and ->

  3. Lambda functions: `a | a -> b(a, x)`
    * `a | b | c` is _simply_ operator overloading for functions, same as `"a"+"b"` for strings.
    * for passing params use inline functions as `a1,a2,a3 | a -> b(a) | c`
    + that uses good(existing) functional intuition, but to make it performant - functions should be macros or transform to direct code, not use lang constructs
    - introduces overload
      ~ it is natural for fnref, as + for strings or & for booleans
    * `a | a -> a + delay(a, time)` is equiv. to `a |> delay(#, time)`
      ~ it's only 1 symbol more + topic placeholder
      + functions are natural arg call placeholders, inventing new scheme to insert args is not DRY
      + fn overloading can be specially defined as `a | gain(amp) = gain(a, amp)`
    * F# style of pipes
    - no easy way to pass to curried function as `source | filter(f, Q)`
      ~ can define overload case as
        * `filter(f, Q) = src -> filter(src, f, Q)` or
        * `src | filter(f, Q) = filter(src, f, Q)` or
          - introduces possibility of definition ops
          - function body here is unnecessary: we ought to mark function as pipeable
        * `filter(src?, f, Q)` = ...`
          + indicates optional argument as existing convention
          + allows indicating which argument is taken "in"
          + no redundant pipe-clause body that introduces ambiguity
          + can expect more than one argument from input, which can be useful for eg fold operator
          - creates curried fn, which is implicit conflicting clause
          - conflicts with just pipe function `x | x -> x+a+b`, vs `sum(x?) = x+a+b; x | sum()`
          ~ the issue is that `?` operator acts as if argument is something very natural and same-level
        * implicitly create a curried function if less than needed arguments is present?
          - too much confusion - not clear which is which. Same-name-fn must not spawn different results.
      ~ can do arrow fn `source | s -> filter(s, f, Q)`
    * makes same syntax assumption as 2. by invoking rhs function with lhs as first argument.
    + doesn't have generic operator overloading meaning as in 4: only applies as first argument.
    - we may not need lambda functions

  3.1 Use topic token 1.1 only as part of pipe expressions but as curried fn constructor as rhs? `a | a->a+1` === `a | ^+1`
    + syntax looks fresh, compact, flowy
    + combines JS's F#/Hack pipes
    + no redundant function calls from 2. (unless we do 4. with constructor/currying meaning)
    + `|` + `^` = `|>`, makes sense
    + reducer operator is as promised, without redundant call: `..combs_a | comb(^, input, room, damp) >- sum`
    ~ Likely there's benefit of limiting topic to pipe only. Generic ^ may have unexpected side-effects.
      + eg. initializer `...a=(x;^+y)` can be `...a=x|^+y` now, since no conflict with semi.

  3.1.1 Likely topic must be `&`, as reminiscence of binary operator pair `|&`.
    + also matches "self" by meaning

  3.2 ~~`filter(-> src, f, Q)`~~
    + benefits of `filter(src?, f, Q)`
    + more explicit indicator of curried clause and piped in argument
    + can be combined with `filter(~>src)`
    - `x,y,z | stretch` vs `x,y,z | stretch(amt)` - both valid and similar, but syntactically nastily different

  4. ~~Function overload `a | b(x) = b(a,x);  a | b(x)`~~
    ~+ Partial application can be thought on its own regardless of pipe as `a1 = a(#, rate)`
      , which is solved via lambda as `a1 = x->a(x,rate)`.
    + `source | gain(.45)` is oldschool coolness.
    + direct meaning definition
    + semantically clear
    - generalized operator overloading
    - too much definition noise, compared to just |> available for every fn
    - comma has precedence below |.
    - `a | b(x)` being replaced by `b(a, x)` is meta-programming, it's not operator overloading
    - there's no difference in `a | b(x)` between OR of result and overloaded function (expression)
      ~ b(x) signature can return b(a,x), not boolean.
    - definition is alternative to `b(a) = x -> b(x,a)`, duplication
    - the definition breaks convention of calling rhs `|` function with first argument applied, eg `x|b(a)=b(a,x)` swaps args.

  5. ~~lambda + `a |> b(x)` as a shortcut for `a | a -> b(a, x)`?~~
    - `...a = a0,a1,a2,a3 |> stretch(rate) | Comb` is too entropic
      - mixing function scope with direct scope
      * vs `...a = a0,a1,a2,a3 |> stretch(#, rate) |> Comb(#)`
      * vs `...a = a0,a1,a2,a3 | a -> stretch(a, rate) | Comb`
      * vs (ideal1) `...a = a0,a1,a2,a3 | stretch(rate) | Comb()`
      * vs (ideal2) `...a = a0,a1,a2,a3 |> stretch(rate) |> Comb()`
    -~ this partial application is implicit argument - non-js intuition.
    - ideally not have additional (shortcut) operator

  6. ~~Internal/implicit variable like `#in` to read from.~~
    - let's try avoiding any implicit values for now, most of them can be done via internal state (+ explicit init args)

  7. ~~Global variables $1,$2,...$n as constant references to last elements in stack?~~
    + then we can use them internally: `gain(amp)=$0*amp`
    + then we can use them in pipes as: `source, modulator | filter(freq:#2)`
    ? or maybe better #0, #1, #2?
      + works better as ordered number meaning
      + github (url) ref
      . #0 - all last args, #1 - first arg etc.
    ? or $0, $1, $2?
      + reminds string replace
      + reminds wasm text reference
      + wasm refers $ to variable name, to named entry in stack (variable or callstack)
    ? or maybe provide named references (unchangeable) #in, #in[0],..., #out, #t, #rate?
      + gives "private", "reserved" meaning, which is similar to private fields from js.
      - no need for #in - function just takes from last group
      + plays well with implicit arguments #t, #i etc.
    - same as 5 - let's avoid implicit stuff

## [ ] Lambda: -> ~~ we can use only lambdas everywhere~~ ~~wasm doesn't have dynamic func references, creating memory for calls is costly~~ no need for now

  * should there be lambda? `value | x -> x*.6 + reverb(x) * .4`
    - lambda function has diverging notation from regular fn definition.
      ~ although `param -> result` is also classical math notation
    + lambda funcs also don't need brackets, just `a,b,c -> a*2 + b*3 + c*4`
    + lambda funcs have no state, they're just in-place routines (I guess level of macros, not table subroutines).
    ‚Üí let's first find out how much these operational pipes are useful. Maybe not.
      + although lambda is useful for currying fns also
    - lambda is heavy to implement: it requires a table, which can be dynamically spawned and needs some gc headache
      ? what if we identify by callsite and in-places denormalize usage as just direct code insertion? Sort of macro?
        ~ then overloading becomes questionable `...a = a0,a1,a2,a3 | a -> stretch(a, rate) | Comb`
      * can be done as single funtion with many args identified by callsite, but in-place we call it with some predefined args
        ‚Üí by spawning a function somewhere, we spawn generic reference with predefined arguments, eg.
        ‚Üí `Comb(a) = x -> x + a` ‚Üí `CombArr(a,x) = x+a;  Comb(a) = CombArr.bind(a)`
  ! ‚Üí operator must uniquely identify type and be macros
  ?! Try x(..args) -> operation for regular functions?

## [x] Operators: Reduce/fold ~~let's use |> with lambdas~~ -> easier to use just loops `sum=0; list |> sum+=_; sum`

  * ? Reduce operator? It can be eg. `:>` (2 become 1), or `=>`.
    * ? `a,b,c :> reducer`, like `signals :> #0 + #1`
      - `:>` looks like expecting some input or something.
    * ? Or maybe `a,b,c ||> a,b -> a + b |...`
    * ? `a,b,c => a,b ->a+b`
    * ? `a,b,c ..> a,b -> a+b`
    ‚Üí `(a,b,c) >- a,b -> a+b` (crazy!)
  ! >- operator can be statically analyzable if group length is known (it should be known)
  ? unrols into single expression for groups OR applies reduce/fold for arrays. Acts as convolver also.
  ? or just avoid that since direct loop is available?
  * -> What if use `|>` for reduce
    + compatible with `map` as `x | x -> x*2 |> (x,y) -> x + y`
    + better visual separation, less linear noise vs `x -> x*x >- (x,y) -> `
    + better mnemonic for `|` as "take these items" (and fold) - like list comprehension or set descriptor
    + It might free syntax space of `-<` for more "inline", "immediate" things

## [x] Units: time primitive and short orders is natural: 1h2s, 20k -> see below

  * Units possibly intrudoced as `10k`, `1s`, `1hz`, `1khz`

  * ? 1pi, 2pi, 3pi, 3.4pi etc.
    + theoretically fractional type would introduce max precision
    ~ more natural convention would be pi2, pi3 etc. which can be simply precalculated.
    - .5pi/2 etc - complicates parsing, makes formulas unusual, occupies 0xa, 12n, 0b2 namespaces.
      ‚Üí very simple to instead do .5*pi, 60*h + 10*m
      ~ occupying that namespace is fine: it still serves similar purpose
      ~ 0.5pi is nice notation too. Same as would be 0.5i.
  * ‚úì 1k, 1M, 1G, 1T
  * ‚úì 1s, 1m, 1h
    * ? 1h12m1s - is it a separate type?
  * ‚úó 0:12

  - we can't include all units anyways, it's pointless
    ~ we don't need all, whereas 2k..20k is very elegant, instead of legacy 2e3..20e3

## [x] Units: convert to sample rate samples (or to floats)? -> try generic units `1k=1000,1s=48000,1pi=pi`

  + saves many conversions
  - has implicit sr variable...
  ?! ~~`@pi=3.14; 2pi;`, `@s = 44800; 1s;`~~
    - `1s === 44800`, not `@s`
    - reserves `@`
    - `1pi1ms1s` mixed units fail
  ?! `1s=48000; 1ms=.001s; 1pi=pi; 3pi5s2ms`
    + solves mono discrepancy
    + laconic, obvious and truthy
    ~+ customizable from outside as `1s=sampleRate`

## [x] Units: what does customization give vs take -> static as much as possible, dynamic otherwise

  + Gives i18l code: 1–º3—Å
  + Gives customization of sample rate: `1s=44800`
    - For external customization `1s=@param.sampleRate` we need dynamic units
  +? Custom math expressions / param values eg. `1step=20`
    -> units must be localized to scope and be dynamic then, if we allow redefining them
  + `1s=44100` solves problem of time vs offset variables
  + `1pi=@math.pi`
  - Duplicated code `1k=1000` in all programs
    ~+ Soft introduction into program
  - Non-compatible definitions, eg. `1pi=3.1415` vs `1pi=3.1415926`
    ~ not a big deal
    ~+ allows some experimentation
  - Non-compatible program code if units are undefined or (worse) conflictly defined
    - `1M=1000000` vs `1m=0.001` vs `1M=1024000`
      ~+ local definition/redefinition can help

## [x] Number types: fractions, complex numbers -> when needed

  + improves precision

## [x] Function: Always return result, or allow void functions? ‚Üí implicit return, same as (a;b) in scopes; solved by required number of output as well

  + always return is more natural practice
  - no-result case is more generic and closer no wasm, by forcing result we limit capabilities
  + less choice is better: when no-result is needed?
  + solves issue of `a(x,y) = x*y.` - meaning export function a, not result. vs `a(x,y) = x*y..`
  ~ makes `.` optional at the end
    ~ makes `.` less common for fn result - mostly limiting to early return as `a(x)=(x?1.;x)` ‚Üê this is fine though
    - we still allow `.` as last token:
      * `a(x,y)=(x*y.)` is valid "result of function", therefore `a(x,y)=x*y.` is too
      * or else `.` depends on `()`: `(a.)` is result, `a.` is export.
  + Since `(a;b;c)` naturally returns last element, so must function body.

## [x] End operator ‚Üí ~~indicator of no-return statement,~~ no for now, last statement automatically returns

  * `.` operator can finish function body and save state. `delay(x,y) = (*d=[1s], z=0; d[z++]=x; d[z-y].)`
  * ? is it optional?
    * eg. `noise(phase) = sin((phase % (PI*2))**3)` - what would be the point here?
  - it makes direct sense only in case of unnested body. When body is nested - not as much.
  - it creates confusion with block as `).` vs `.)`
  + maybe for unwrapping it is still useful.
  - conflict with global variables init. x=1+2;y()=x+1. - like, why? better make as simple assignment.
  * ? make it an alternative to semic? semic is too noisy as separator, eg. (a,b,c; ^+1) ‚Üí (a,b,c. ^+1)
    + keeps natural aesthethics.
  * ? make it indicator of "return" statement?
  * ? make it indicator of "end pipeline"?
  * ? make it null literal?
    + works as "end function without result" a -> b().
    + works as fn args as `a(b,.,c,.,e)`
      - sheer redundance
  * ? it can act both as "return" and "save state" indicator for scoped blocks.
    + enforces semicolons and adds clarity.
    - both are unnecessary; it's natural to return last item without indicator
    - makes confusion
  * ? + can be used as export marker in a module.
  * + we may need early return as a() = (a?b. c+d.)
  ‚Üí (a,b,c) returns group; (a;b;c) returns last; (a;b.c;) returns b but requires ; as `(a;b.;c;)`; (a?b.:c;d) returns b or d.
    * the logic is: group figures out result based on end indicator, else takes full internal value.
  ? we can force end operator to stand after a separate id, not expression.
    + bans `pi2 = pi*2.; rate = 44100.;` ‚Üí `pi2=pi*2;rate=44100; pi,rate.`
      - doesn't help much if expr comes after, eg. `pi,rate. a=3;`
    -> so seems uncovered period can stand only at the end of scope. Else there must be a semi.

### [ ] End operator `.` (discussion above is old): to have or not to have? -> use `(a;/)` for void return

  1. `a,b,c.` explicitly indicates exported members
      - we can do export by last statement as `a,b,c`, thinking it be similar to fn return
        + fn return is unnamed, module exports is named
        + module exports cannot return numbers or just values
      - confusing intuition: `./a,b,c` returns `a,b,c`, but `a,b,c.` exports `a,b,c`.
    + tribute to Erlang's and natural langs PERIOD.
    - `a,b,c` - less conflict with other `.`-including operators.
    - less is more
    - no-period allows easier concat of modules.

  2. `a,b,c.` for void - return nothing
    + end = no return, which is logical
    + matches `./` intuition: it would be `(a;./b)` to return something, but we just do `(a;b.)`to force returning none
    - `(a;/)` === `(a;.)`
      - in coffee, if you want to return nothing, make it explicitly: `(a;/)`
      + we can do explicit indication `(a;b.)` - means return nothing
      ~+ `./` can be used only for loops, since it's `continue`
    -? `./` as `. /` (void return)
      + void can only be postfix unary `a.;`
    + resolves last semicolon confusion - now `;` can always return last statement even with semicolon, unless `.` indicates nothing.
      ~- not so elegant as just skipping semi
    + typographical, erlangy
    - `.` could've been used as part of name (like stateful instance) or static props in the future

  3. void return `(a;b;/)` (like coffee)

## [x] Early return operator? ‚Üí ~~keep `a ? ^;` for now~~ `./`, `../`, `/` is most logical

  * can often see `if (a) return;` - useful construct. How's that in lino?
  1. `a ? value.`
    * There doesn't seem to be other options.
    ‚Üí `a ? b.;` expects `;` at the end.
      * skipping ; means node is the last element: `(a;b;c.)`
    - `?` ~~operator is void~~
      ~ can be in conjunction with `.` so then it's a kind of ternary.
    ?+ `a ? b. : c` === `if (a) return b; else c;`
  2. not supporting early return.
    + simpler flow/logic
    + no (b.c;d) syntax case
    + gl code doesn't support preliminary returns as well as optimal branching, so maybe meaningful
    - no reason to not have it

  3. Guard / early return operator?
    + we don't want to introduce void `a?b;` identical to `a&&b`
    + the only way to use early func return is via `if(smth)return`, is there anything else?
    + break, continue also happens always via `if(smth) break`
      + we don't want much to introduce `^`, `^^` operators therefore, they can be used for topic holder
    + so it's more known as function/block guards
    + it's potentially easier for analysis, since we exclude fancy returns and just do conditional breaks
    -? what should that return? It's still void operator.
  * `cond ?.; cond ?. b; cond ?.. b;`
    - conflicts with JS `a?.b;` which means optional access
    + matches end of program `.`
      - end of function is not denoted
    + matches paradigm of paths: `.`, `..`
    - `cond ?. 0;` vs `cond ? .0;`
  * `cond.?; cond .? a; cond ..? b; cond ...? b;`
    - a bit unnatural order
  * `cond ? b.; cond ?. ; cond ?..; cond ? c..;` (see 1.)
    + ideal from the natural point of view
    + works nicely with pipes: `a |> (_ > 10 ?.;)`
    ~ some conflict with optional JS paths
    ? how to make break 2 scopes, or alternatively continue loop?
      !? for continue `a < tsh ?..;`
        + matches typographic meaning
        - inverse paths meaning `.`, `..`
        - `a < tsh ? val..;` is identical to range
          ? is that so bad that it matches range? it is kind-of indicator to "continue" range
            * yes: how do we know if it returns sequence or just one element?
              +~ noone returns infinite sequence as result
          ? continue / break don't return values, do they
            ~ it can return result, or can discard result.
          - confusable `a < tsh ? ..4;` and `a < tsh ? 4..;`
            ~+ continue with infinite sequence from either side is meaningless
              ~ we can make some meaning for `..4`, like "put value at the end" or something
          ~ we also use range in indirect way in assignments as `(a, ..last) = (1, 2, 3, 4)`
            + actually `a < tsh ? ^..;` and `a < tsh ? ..^;` is nice indicators of how to proceed with loop:
              * either processing the rest after current element `^..`
              * or before current element `..^`
              ~ before-range creates `a ? ..b;` operator, which invites `a ? ..b : c`
      ? for continue `a ? >b;`
        + matches pipe operator `a,b,c |> ^ > 3 ?>; ^ > 8 ? .;`
      ? for continue `a ? b,;`
        + means continue sequence literally
        - may conflict with
  * `cond ? (.); cond ? (..); cond ? (../a); cond ? (.../a); cond && (..);`
    + matches paths pattern
    + matches nextjs
    + can augment returning argument
    - doesn't introduce "early return"
    - introduces single-branch if
    - not natural to wrap into braces
  * `cond ? ./; cond ? ./x; cond ? ../x; cond ? .../x; cond && ../x`
    + no conflict with ranges
    + nextjs pattern
    + literally paths
      - confusable pattern in mind
        + memorable due to that
      - can get mixed up with imports
        ~+ we aren't going to provide path facility (for imports), use `imports.json` file
    + has "close" hint `/` with end hint `.`
    + associates with "end" meaning of `.`, `/a,b,c` for whatever comes after period.
    + allows having return in alternative branch: `cond ? x : ../y;`
    + frees `^` (for topic holder)
      + no conflict with XOR really
      + conventional pipe `|> ^`
    + resolves conflict of `#` as topic placeholder vs variable
    - some interference with ranges `..; ../; ./; .../; ..a/b;`
      ~ actually that associates with ranges better, since ranges are indicators of loops
    + associates with ranges in a sense `../x` for finish current range with x value
    + reinforces end operator
  * `cond ?./; cond ?./ x; cond ?../x; cond ?.../x;`
  * `cond && ./; cond && ./x; cond && ../x; cond && .../x;`
    - mind-bending to see `(a && return b)`
  * `cond ./; cond ../ x; cond .../x;`
    - not obvious enough
  * `a > b (.); a > b (..) x; a > b (...) x;`
  * `cond ?/; cond ?/ x; cond ?// x; cond ?/// x;`
    - not following patterns
    - conflicts with comments
    + consistent with `./` for skip, `../` for break
  * `cond ?< b; cond ?<; cond ? <<b;`
  * `cond ? =b; cond ? .=b; cond ? := b`
  * `cond ?= b; cond ? ==b; cond ?=;`
  * `cond ? b*; cond ? *; cond ? **;`
    + period, but more obvious
    + matches state var as `*a` - beginning, `a*` - end.
  * `cond ?^; cond ?^ a; cond ?^^ b;`
    ~ no need for one operator, can be `?` and `^^` operators
      - which is undesirable
      + doesn't have to introduce separate `?` and `^`.
    + matches beginning of ternary
    ~ we may still want to have if operator `?`.
      ~ or not
  * `cond!; cond!b; cond!!b;`
    - `!a ! b;`
    + clear option for guards, like `a > 3 !;`
      * it's inverse early return: it ensures function body passes the condition, not vice-versa, eg
      * `a <= 3 ! ret;`
    - not clear how to break 2 scopes or break loop `(list <| (#!; #*#))` filter & map
  * `cond!?; cond !? b; cond !? c;`
    + no conflict or even direct mention of ternary
    + hints to ternary as "special exiting condition"
    + no postfix operator as in `cond ? x !;`
    + sort of meaningful in sense of "inversed condition", like "stop condition".
    ~ looks a bit quirk `a !? b;`
    - `a !!? b;` is heavy
    - `a!;` can possibly be reserved for throwing errors
  * `cond ? x!;`, `cond ? x!!;`, `cond ?!;`
    + continue, break, return
    + builds into ternary operator
    ~ blocks if operator, which is sort-of fine
    ~- reminds inversion, which is undesirable
      ~- creates alternative association with `!` as `stop`, `break`
    +- makes use of postfix operator
  * `a :? b`
  * `cond ?:; cond?:b; cond?::b;`
    - matches elvis visually, but not by meaning
  * `cond:; cond: a; cond::b;`
  * `cond<>; cond<a>; cond<<b>>;`
  * `<cond>; <cond> a; <<cond>> b;`

  4. `a..b |> (x < 10 ?>; x > 100 ?.)`

## [x] Return operator: alternatives ‚Üí try `/` for returning value from ~~block~~ function.

  1. `.`
    + erlang-y
    + very natural
    - early return is weak `a ? b.;`
      - can't suppress semicolon: `a ? b. c + d;`
    - exported global is confusing `sampleRate = 44100.;`
    ~ `c()=1.`, `c()=1.0.` - weirdish constructs, although clear
    - semi after the result.
  2. `a ? b...;`, `sampleRate = 44100...;`
  3. `a ? b!;`, `sampleRate = 44100!;`
    - as discussed in other topics - `!` can be reserved for throwing errors.
  4. `a ? b :| c + d`, `sampleRate = 44100:|;`
  5. `a ? ^b;`
    + less confusion with `.`
    - doesn't look natural when at the end there's `a() = (...; ^out);`
      + it doesn't necessarily required: last element is returned by default.
    + allows `.` for short float notation.
      -~ `1...2.` can be messy
    + allows return none / break notation.
    - enforces `?`, `^` operators
  6. `a ? ./b;`
    + frees `^`
    - conflicts with skip
  7. `a ? \; a ? \b; a ? \\b,c;`
    - without return doesn't look good
    - not heavy enough
  8. `a ? #; a ? #b; a ? #b,c;`
    + `#` reads as `=//` visually
    + heavy enough
    - `a ? #.;` === `a ? #;` if `.` is void
    - `#` has heavy alternative associations
    - doesn't match skip, stop
  9. `a ? /; a ? /b; a ? /b,c;`
    + matches `./`, `../` logically

  10. `a ?= 10; =20;`

## [x] Break, continue, return? -> `./` for continue, `../` for return, `/` for root return.

  1. ~~`^` for continue, `^^` for break;~~
    + nice pattern to skip callstack;
    + brings point to prohibiting `^` as reference to last expression: simpler pipes;
    + combinable with return statement which is kind-of natural `(a?^b; c)`.
    - wrapping in parens can change the meaning or scope of `^^`.
      ~+ not really: it's visible that it breaks recent scope.
    + it seems going to live longer than `value.`
    + gives nice feeling of direction in language, meaning visually "get out of this scope"
      + that supports piper `|>`
    - a bit cryptic to see `^^^a`, as if some magic happens
    - taken by 'defer'
  2. `>>` for continue, `^` for break.
  3. `.` for break or return, acting within the block; `^` for continue.
    - break can be used without stack argument, `.` by itself doesn't do much sense although possible
    - `tsd(i) = (i < 10 ? (log('lower'); 10.); i)` may expect returning from the function, not breaking the block.
      -> can be used as `tsd(i) = (i < 10 ? (log('lower'); 10).; i)`
    + the most laconic version
  4. webassembly doesn't use continue, just `^` for break.
  5. `a ? >| : >>|;`
    + fast forward, skip, break
    + matches pipes
    - not in code fonts
    - noisy: `a |> _ ? >||>>||> ` - is that `|> >| |> >|` or `| >> || >> ||`
  7. `a ? -| : --|`
    - not associated with skip/forward
  6. `a ? -> : =>`
    - too heavy assoc with fns / maps
  7. `.. |> x > 3 |?> ` - rethink into pipe filtering
    - doesn't bail out arbitrarily

  ? If `?.` is return from function, then how to break (early return) current scope?
  ? If `?..` is early return current scope, then how to break loop?
    * we can avoid return generally and only bail out from current scope.

## [x] Break, continue, return: from block or from function? -> ./ skip, ../ stop, / return, no block return

  1. `./` - break block, `../` - break 2 blocks, `.../` - break blocks to the root
    + consistent with loops: `.. |> ./`
    - sensitive to parens `.. |> (./)` != `.. |> ./` - weird
      + since parens are sequences `(a;b;c)` we have to have a way to early return `(a?./;b)`
      -? how do we handle when we need continue/return from within parens?
    - `.../` is not necessary for function return
    - `.../` vs `.. ./` vs `. .. /` vs `. ../` vs `.. . /`
  2. `./` - skip/continue, `../` - stop/break, `/` - fn return (no parent sensitivity)
    + meaningful for loops
    + same as all langs now (simple)
    -? how to make return from within the loop?
      !+ `/x` as absolute-level return
    !+ `(../x)` can be used as a way to break block as well, opposed to `(/x)` as absolute return
      - if `../x` breaks block it makes it susceptible to parens around, which is not what we want
    - `../` vs `. ./` vs `.. /`
      ~+ we never need void nor return inside of range
    -? how to early-return parens?
      a. `(a?b.;)` - make void operator act as returning operator.
        + it anyways breaks current fn scope and used as last operator
        + void operator has too little meaning anyways
        -? how to return, not break?
      b. we don't have parens return, use ternary `(a?b:c)`
    -? how to define blocks?
      ~? langs don't define blocks unnecessarily, why do we need it?
  3. `^a` - skip, `^^a` - stop, ??? - return
    + debugger means skip
    + avoids conflicts with `.` for void etc
    -? conflicts with defferred
  4. `a.|` - skip, `a.||` - stop, `a.` - return
    + connects to pipes as "next member" `.. |> a ? b .| : c ..|;`
    - similar to `./` but less familiar
      ~+ maintains similarity with paths
    + connects with end as `a.`

## [x] Defer: -> ~~`x(a) = (/log(a); /a+=1; a)`~~ ~~`x(a) = (^log(a); ^a++; a)`~~ or `x(a) = (;;log(a); a++; a)`

  + like golang defer execution runs item after function return
  + allows separating return value from increments needed after function
  * no deferring?
    + obvious code sequence
      + conceptually it's not nice to make code spaghetti-like
    + no conceptual/syntax/mental layer over operator
    - definition of static variable and its change are separate
      ~ potentially change can depend on certain conditions
    - noisy code of creating result holder var, performing state update, returning result
    + kind of natural
  * ~~`x()=(@a;b,c;@(d)); x()=(*i=0;@i++;)`~~
    + `@` for after
    + good candidate by chatgpt as it's used for "annotations in Java/C#, so associated with modifying behavior"
    - brings `@` into local scope
    - not straight meaning
    - makes `@` an opertator - it's reserved for name now
  * ~~`x() = (//a; b,c; //d;)`~~
    - strong association with comment
      + maybe that's a pro
    + if `./` is return, `//` means after return
    - `x() = (#a; //a++;)` looks intimidating
  * ~~`x() = (*i=0;\i++;)`, `x()=(\a; b,c,; \d;)`, `x(a) = (\log(a); \a+=1; a)`~~
    - a bit too heavy by meaning
    - `\` doesn't match up with anything and has universal sense as `escape`
    - ~~takes away cool `\\` as comments~~
  * ~~`x() = (*i=0;**i++;)`, `x()=(**a; b,c,; **d;)`, `x(a) = (**log(a); **a+=1; a)`~~
    * `x()=(*a=[0,1];**a[1..]=a[0..])`
    - creates faux double meaning for `*`
  * ~~`x() = (/a; b,c; /d;)`, `x()=(*i=0;/i++;*phase=0;/phase+=t;)`, `x()=(/log(a))`~~
    + one-symbol
    + associates with reddit tags
    + associates with HTML close-elements
    + generally "close" meaning is `/`
    + complementary with `*` as `*a=0; /a++;`
      - reinforces meaning of opposites `*/`, which is not the case here (false friend)
    + doesn't feel like part of identifier
    - ~~too many slashes `/a/b //divide a by b`~~
      ~+ comments are `;;` now
    - association with something not-end, like `/imagine` or etc.
    + plays along with `./a; ../a;` for return, and `/a;` for just defer.
      - maybe creates unnecessary confusion
    - `.. /a` vs `../ a`
    - if `./` is continue, then `/` is weird for defer
    - `#x;/x++` has slight dissonance
    - used for "return"
  * ~~`x() = (&a; b,c; &d)`~~
    + meaning of "and also this"
    + also "counterpart" of `*` from C-lang
      + it was even an alternative to `*` in the beginning
    - has meaning as "part" of identifier, not operator (higher precedence)
      - ie. `&i++` raises confusion, it's not `&(i++)`, it's `(&i)++`
  * `x() = (~a; b,c; ~d)`
    + very strong sense of "destructor"
    + relatively safe within other options: `/i++, \i++, &i++, 'i++, #i++, @i++, >>i++, .i++`
    + follows spirit of C in terms of "common" operators choice `*, ~`
    + `~` means "after all that is here"
    + `~` also means "delete" or "erase" in markdown
    + minimal noise
    + a candidate by chatgpt since brings sense of "something in the future (skip this noise)"
    - subtle dissonance with `*`: `x()=(*i=0;~i++;)`
    - `x()=(*i;~++i)` is too cryptic: `~` doesn't stand out from regular operators
      ~ `x()=(#i=0;~i++;)`
      ~ `x()=(#i=0;^++i;)`
    - reserved for unary "binary inversion", already married
    ~- reserved for ranges
  * ~~`x() = (a.; b,c; d.)`~~
    + meaning "at the end"
    + same operator is used for export
    - not immediately obvious that it's deferring `*phase=init; phase+=(iterating,phase).;`
    - not nice with `*i=0,i++.;`
      - not clear if the whole phrase is at the end or just i++
    - `.` is for void operator
  * ~~`x() = (.a; b,c; .d)`, `x() = (*i=0;.i++;)`, `x()=(.a; b,c,; .d;)`, `x(a) = (.log(a); .a+=1; a)`~~
    - has wrong associatino with property access
    - not easy to find-select
  * ~~`x() = (&i=0;*i++)`~~
    - takes away "save" meaning
    + star means "footnote", like "afterword" in typographics
    + `&` means "with" for variables, it was main alternative to `*`
    - `*` has too strong association with "save"
  * `x()=(#i=0;>>i++;)`, `x()=(>>a; b,c,; >>d;)`, `x(a) = (>>log(a); >>a+=1; a)`
    + clear meaning of "shift"
    + Sercy sneezed
    + related to playback's `>>` as fast-forward
    + requires some operand, cannot be on its own in case of continue
    + good candidate by chatgpt: "could suggest ‚Äúpushing‚Äù an operation after the function"
    - association with C++ pipe (cout)
    - something more like "side return" or "write somewhere"
    - 2 chars, opposed to 1 char in `^i=0;`
    - a bit too much visual noise, defer doesn't have primary meaning
      - `>>++i` is line noise
  * ~~`x() = (*i=0;>i++;*phase=0;>phase+=t;)`, `x()=(>log(a);>a+=1;)`~~
    + refers to `>>`
    + obvious that there's something fishy going on
    + refers to "quote" from markdown
    + minimal
    + adds to the feeling of flow
    + association with terminal's command "output"
    - breaks loop `a |> b` into `a | >b`
      ~ fixable-ish via precedence
      ~ loop has never defers (?)
      ? can we change loop to `?>`, so it means "until condition holds, defer code"
    - a bit heavy, ruby-like, unfamiliar vibe
  * ~~`x() = (*i=0;>|i++)`~~
    + `skip forward`
    - too many symbols
    - somehow related to pipes
  * ~~`x()=(*i=0;=>i++;)`~~
    - equals noise
    - faux function association
  * ~~`x()=(*i=0;'i++)`~~
    + refers to footnote
    - quotes usually come in pairs
  * ~~`x()=(*i=0;#i++)`~~
    + refers to footnote~~
    + like hashtags, comes afterwards
    - a bit too heavy to reserve such prominent operator for just deferring
    - reserves # as operator
    + includes notion of "double", like double hash `//` in it
      ? is that why python uses # instead of // for comment?
    + associates with comment, something that comes "after"
  * ~~`x() = (*i=0::i++;)`, `x()=(::a; b,c,; ::d;)`, `x(a) = (::log(a); ::a+=1; a)`~~
    - noisy
    + meaningful in semantic sense (after all ops)
      - not really. `a : : b` means do it once now
    - has connection to static props in langs
  * ~~`x() = (*i=0;:i++;)`, `x()=(:a; b,c,; :d;)`, `x(a) = (:log(a); :a+=1; a)`~~
    + 1-character only
    + kind-of matches meaning of labels in JS
    - a bit clumsy
    - has connection to types in langs
  * ~~`^` for return, `x() = (*i=0;^:i++;)`, `x()=(^:a; b,c,; ^:d;)`, `x(a) = (^:log(a); ^:a+=1; a)` for defer~~
    + means "after return"
  * `x() = (*i=0;^i++;)`, `x(a) = (^log(a); ^a+=1; a)`
    + means "delay" operator in DSP
    + means "after return"
    + `^` and `A` have similar shape
    + reminds debugger's jump over icon ‚Ü∑
    ~+ `x() = (*i=0;^i++;)` - balance of familiarity and novation
    + `^` means footnote in typographics
    + can go last literally to reduce unary intimidation
      + if that's the case, literally means "return prev statement"
    - has more "operator" sense than positional
  * fn return as: `=a*b`: means take expression as function result `f()=(*i=0; =...; i++)`
    + avoids problems with last expression
    + avoids accumulated stack issue
    - `f() = ( *t=0; =t*2; t++ );`
      - intimidating prefix operators, `=` must be less standard practice
  * `x() = (i=0;abc;;i++)`, `x()=(*i=0;;i++; ...)`
    + gentle indicator of "after all sequences"
    + extends meaning of `;` operator
    + has better "positional" sense rather than operator sense like `^`
    + defer has to do with sequence indeed, not with "own land of meaning"
    + refers to `for (i=0;;i++)` as `defer` is last statement there
      + that is sort of good pattern
    - `;;a;;;b` - what's that?
      ~ `b` is deferred
    - `(a;;b;;c;d)` - which part goes last which first?
      ~? `b` and `c` are deferred
    - not easy to make multiple statements `(a;b;;(a++;b++))`
      ~ `;;a;;b`
  * `x(a,b,c; i=0, y=2; i++) = (...)`, `x(a,b,c,.t; t++) = (...)`
    + a bit like `for (init;;after) = (...)`
    + no new syntax introduced
    - no access to local vars
    - messy multiple statements `x(a,b,c;(a++,b++)) = (...)`

### [x] Defer/return: !Return to stack `=a;=b;` same as `a,b;` -> likely no need, just use defer
  + allows avoiding drops
  + points at how assignment works
  + allows organizing deferred `f()=(*i=0; =...; i++)`
  - from groups perspective `=a` is `,=a,`, which is "assign to nowhere"
  - accumulating stack is dubious, something from asm
    - `0..10 |> =#`
      ?- can we put arbitrary len items to stack
        + we may know stack in advance, so yes, nulls
        + we may use array for complex cases
      ?- conflicts `a[..] |>= # * 2`
  - blocks common postfix ops, eg. `a!` becomes `a!=b`
  - requires void or drop
    a. we make last `;` sensitive, in sense `a;` means drop
    b. we make void as `f()=(*i=0; =...; i++.)`
      - too much effort for simply defer
    c. syntax order `f()=(*i=0; (=...), i++;)`
      - trick rather than normal practice
      - doesn't replace stack
    d. some marker for deferred area eg. `f()=(*i=0;...;i++)`
      - can't think up obvious marking for such block
      - that marker is essentially "omit output"
      ~ that case is already covered by "defer" operator: just put statement at the end if you wish so

## [x] !Prefer operator `x()=(a;<<x=1;a*x;)` - declares values at the beginning? -> nah

## [x] Export: ? Can we use something else but . for export? ‚Üí ~~let's try `a.` as global export operator~~ -> last members are exported by default

  - that seems to create confusion for `a(x,y) = x*y.` case
  - that doesn't seem to belong to natural languages - marking . with export.
  - it seems export is better marked before declaration, than after.

  1. ~~`::a(x,y) = x*y.`~~
  2. ~~`!a(x,y) = x*y.`~~
  3. ~~`#a(x,y) = x*y.`~~
    - conflicts with cardinality
  4. ~~Can we export all by default?~~
    - that bloats default module size
      ~ can be mitigated on imports: main compilable file exports everything, the rest is treeshaked
        ? how do we `export x from './x#x'`?
          `@ `./x#x`; x;`
    + exporting each member is tedious and too much code noise.
      + that's sometimes js trouble that exports is not exported etc.
  5. Export everything by default, except for methods marked "private", eg. _abc (convention).
    - _abc forces unnecessary noise across the file. It's easier to mark variable private just once.
    + Cobra lang uses __abc for private and _abc for protected...
    - bringing meaning to variable name symbols can be unintuitive.
  6. ~~We can use @ for export as well as import.~~
    + Ruby has @ for protected methods, which is alternative to _abc
    - mixes up imports/exports: it's hard to see what's what in the file
  7. We can export last function/group, as regular groups do.
    - not very explicit
    - can be mixed with declarations
    - not very apparent
  9. Use `a,b,c.` as (last) operator in the file
    + reverence to erlang and natural languages
    + explicit
    - relative conflict with preliminary return in functions `a -> (^x; y)`
    + file starts with import operator, and ends with export operator.
  9.1 `.` means end of program, last members are exported.
    + `a,b,c.` exports
    + but also just `fn().` indicates end of program
    + `.` is self-sufficient
    + `.` is replacement for `;`
    ?! missing `.` means program is unfinished? like, a library to include?

## [ ] Static variables: syntax ‚Üí `*` seems to be most natural for save

  * There's disagreement on `...` is best candidate for loading prev state. Let's consider alternatives.
  1. ~~`...x1,y1,x2,y2`~~
    + clear
    + matches punctuation meaning
    - ostensibly conflicts with ranges .. (imo no)
    - goes against spread convention
    - possibly doesn't indicate well enough if ... is applied to group or first item
      + to a group. It is super-useful to have list of stateful variables.
    + doesn't pollute variables with any prefixes
    ```
    lp([x0], freq = 100 in 1..10000, Q = 1.0 in 0.001..3.0) = (
      ...x1, x2, y1, y2 = 0;    // internal state

      w = pi2 * freq / sampleRate;
      sin_w, cos_w = sin(w), cos(w);
      a = sin_w / (2.0 * Q);

      b0, b1, b2 = (1.0 - cos_w) / 2.0, 1.0 - cos_w, b0;
      a0, a1, a2 = 1.0 + a, -2.0 * cos_w, 1.0 - a;

      b0, b1, b2, a1, a2 *= 1.0 / a0;

      y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;

      x1, x2 = x0, x1;
      y1, y2 = y0, y1;

      [y0]
    )
    ```
    - `song()=(...t=0;)`

  1.1 `.x, .y, .z`
    + minimal look
    + associates with "static members" in swift
    + doesn't create new syntax
    ```
    lp([x0], freq = 100 in 1..10000, Q = 1.0 in 0.001..3.0) = (
      .x1, .x2, .y1, .y2 = 0;    ;; internal state

      w = pi2 * freq / sampleRate;
      sin_w, cos_w = sin(w), cos(w);
      a = sin_w / (2.0 * Q);

      b0, b1, b2 = (1.0 - cos_w) / 2.0, 1.0 - cos_w, b0;
      a0, a1, a2 = 1.0 + a, -2.0 * cos_w, 1.0 - a;

      b0, b1, b2, a1, a2 *= 1.0 / a0;

      y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;

      x1, x2 = x0, x1;
      y1, y2 = y0, y1;

      [y0]
    )
    ```
    ~- `a..b` vs `a. .b`
      ~ `a.` is illegal
    - looks like mandatory part of variable
      - `.i=1; --.i`
    + `.abc` has sense of "class" from CSS

  2. `^x1, ^y1, ^x2, ^y2`
    - ~~too many meanings to topical operator~~
    + refers as "belonging" to the function
    + doesn't create opposites `*/` for static `/` defer.
    - doesn't feel like static (yet), `#x` is more direct intuition

  3. `*x1, *x2, *y1, *y2`
    + existing convention of `*` as save
    + "star operator" for "save"
    + star also refers to "new", since it clones a function as well
    . C / Rust / Go pointers are the same.
      > It (* - dereference operator) can be used to access or manipulate the data stored at the memory location, which is pointed by the pointer.
      > Any operation applied to the dereferenced pointer will directly affect the value of the variable that it points to.
      . `int x=9, y; int *ptr; ptr = &x; y=*ptr; *ptr = 8`
        - * implies variable is pointer, & implies variable is value.
        + * is more ambiguous than &: & gets address of a value, * indicates pointer declaration, as well as assigns (saves) value: it acts almost as part of variable name.
      + C intuition for "save" value by pointer is `*value = 123`
      - conflicts with pointer intuition in C, it's too much to remember - yet another meaning for `*`
    + Go pointers don't have pointers arithmetic, so we're not going to need pointer assignment
    ~+ group can be defined as `*(a=0,b=1)`
    ~ `song()=(*t=0;)`
    + used in JS for generators and other "additional" stuff
    - hard to "find all" since * is not part of id
    ```
      lp(x0, freq = 100 ~ 1..10000, Q = 1.0 ~ 0.001..3.0) = (
        *(x1, x2, y1, y2) = 0;    // internal state

        w = pi2 * freq / sampleRate;
        sin_w, cos_w = sin(w), cos(w);
        a = sin_w / (2.0 * Q);

        b0, b1, b2 = (1.0 - cos_w) / 2.0, 1.0 - cos_w, b0;
        a0, a1, a2 = 1.0 + a, -2.0 * cos_w, 1.0 - a;

        b0, b1, b2, a1, a2 *= 1.0 / a0;

        y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;

        x1, x2 = x0, x1;
        y1, y2 = y0, y1;

        y0
      )
    ```
    - looks like Python's/Kotlin splat operator `*(a,b,c)`
    - not distinct from common operators

  3.1 ~~`x1*, x2*, y1*, y2*`~~
    + typographic meaning as footnote
    - `x1*=2`

  4. `#x1, #x2, #y1, #y2`, `#(x1,x2,x3)`
    + private state from JS, act as instance private properties
    + sense of "private", "behind the cell"
    + indicator of special meaning
    + doesn't clash with known operators
    + compatible with `#` for "current value" in loops, as indicator of scope-specific variable
      ~- makes global access like `fn.#t` not nice
        ~- otherwise if `#` is operator - then makes `#` for current value meaningless
          ~+ we don't use `#` for current value
    + closer to name of the variable than * etc
    + known use case is `#define PI 3.14`, which can be simplified as `#pi=3.14`
      + that gives "directive" sense: allows reuse `pi` without prefix and shows it's called only once.
        ~- not necessarily good feeling
      + gives sense of "global"-ish
        - it's not really global
    + easier to search separately from maths
      + easier to handle in compiler
    -~ conflict with note names A#
    - ~~pollutes the code with #x1 etc.~~
      ~+ we use it as operator, not part of variable
    - doesn't look like operator
      ~+ we need it distinguishable from common operators
    - often means compiler directive or comment, gives feeling of something global
      ~ which makes it less of operator
    - ~~may conflict with cardinal number (count) operator~~
    - reserves `#` as operator, not part of variable name
      - cannot use notes, indices `x#1, x#2`, placeholder `a |> #`
    - has too strong sense as "global declaration", outside of program
      - if private, we can't use as static reset access `f.x = 0`

  5. ~~`[x1, x2, y1, y2] = #`~~
    + involves destructuring syntax
    - introduces unnecessary token
    - `#` is hardly works on its own not in conjunction
    - `#` is reserved for too many things: count, import, comment.

  6. `<x1, x2, y1, y2>`
    - doesn't come along with regular definition `x=1, <y>=2`
  7. ~~Introduce keywords? Not having if (a) b can be too cryptic.~~

  8. `$x1, $x2, $y1, $y2`
    + $ means "save"
    + $ means "state"
    + $ means "self"
    ¬± $ means money
    - speaks little about persistency
    - perceived as var name, not an operator
  8.1 `$(x1, x2, y1, y2)`
    - perceived as fn call, not operator

  9. `&x1, &x2, &y1, &y2`
    + means "arguments and x1, x2, y1, y2"
    - from C logic means "get address of value"
    + doesn't indicate & as part of name, more operator-y
    - conceptually different from binary / boolean operator, looks same
    ```
    lp([x0], freq = 100 ~ 1..10000, Q = 1.0 ~ 0.001..3.0) = (
      &(x1, x2, y1, y2) = 0;    // internal state

      w = pi2 * freq / sampleRate;
      sin_w, cos_w = sin(w), cos(w);
      a = sin_w / (2.0 * Q);

      b0, b1, b2 = (1.0 - cos_w) / 2.0, 1.0 - cos_w, b0;
      a0, a1, a2 = 1.0 + a, -2.0 * cos_w, 1.0 - a;

      b0, b1, b2, a1, a2 *= 1.0 / a0;

      y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;

      x1, x2 = x0, x1;
      y1, y2 = y0, y1;

      [y0]
    )
    ```
    ~ `song()=(&t=0;)`
    + complementary with `*` as defer operator

  10. ~~`@x1, @x2, @y1, @y2`~~
    + 'at' means current scope, 'at this'
    + more wordy - less operator-y, as if part of id
    + matches import directive by meaning
    ```
    lp([x0], freq = 100 in 1..10000, Q = 1.0 in 0.001..3.0) = (
      @x1, @x2, @y1, @y2 = 0;    // internal state

      w = pi2 * freq / sampleRate;
      sin_w, cos_w = sin(w), cos(w);
      a = sin_w / (2.0 * Q);

      b0, b1, b2 = (1.0 - cos_w) / 2.0, 1.0 - cos_w, b0;
      a0, a1, a2 = 1.0 + a, -2.0 * cos_w, 1.0 - a;

      b0, b1, b2, a1, a2 *= 1.0 / a0;

      y0 = b0*x0 + b1*x1 + b2*x2 - a1*y1 - a2*y2;

      x1, x2 = x0, x1;
      y1, y2 = y0, y1;

      [y0]
    )
    ```
    - feels a bit heavy for internals
    - we reserve @ for param declarations

  11. ~~`:> x1, x2, y1, y2`~~
    ~ `song()=(:>t=0;)`
  12. ~~`:: x1, x2, y1, y2`~~
    ~ `song()=(::t=0;)`
  13. ~~`<< x1, x2, y1, y2`~~
    + Matches ^
      +~ ASCII in 1962 had <- character for _, which was alternative to ^
    - `song()=(<<t=0;)`
    - opens tag

  14. `a.x1 = 1; a.x2 = 2`
    + literally what it is

  15. `&.x1 = 1; &.x2 = 2; &.(x1, x2) = (1, 2);`
    + literally what it is
    + CSS literals technique

## [x] Variables: Binding/referencing variables via pointers? ‚Üí no

  * Purpose of pointers in go is to pass value by address, rather than copying.
  * Also it can create references to a variable in memory.
  * We use arrays for that purpose, therefore we don't need pointers syntax replica.

## [x] Named array items ‚Üí ~~yes, useful and organic replacement for object structs~~ -> not possible to make arbitrary-argument aliases

  * named properties in arrays? `[1,2,3,a:4,b:5]`
    ~ reminds typescript named tuples
    ~ should find exactly where we'd need that
  ? Maybe can be done purely as aliases for position? Let's see for use-case
  + in JS that's frequent good-to-have
  + that would organically introduce pattern of named fn arguments either `gain(volume: 1)`
  + named group items are also useful: `oscillators = (a: x->y, b: x-y)`
    - we don't have groups as primitives
  - conflicting convention: we don't really use labels anywhere (we use variables instead)
  - it kind-of entails lambdas, which we want to avoid also (see `a: x->y` above)
  - requires strings to implement dynamic access `x['first']`
  - some arrays have aliases, others don't: we're not going to make aliases dynamic

## [ ] Conditions:

  1. `a ? b` returning b or 0, elvis: `a ?: b`
    + organic extension of ternary `a ? b`, `a ?: b`.
    - weirdly confusing, as if very important part is lost. Maybe just introduce elvis `a>b ? a=1` ‚Üí `a<=b ?: a=1`
    ~- it has no definite returning type. What's the result of `(a ? b)`?
      ~+ `b` or `0`?
      ~+ likely returning type is never going to be needed
      ~+ it's 0, ie. kind-of step function `a ? b`
    * return type is `0` or `typeof b`
    - burdens `?` with semantic load, impeding other proposals like `try..catch`
      ~ there's a chance try..catch is not going to be needed
    !? What if `a ?! b`, which is essentially `!a ?: b`
      + no conflict with ternary `?:`
      - nah, wrong ordering, we inverse `a`, not `b`
    !? What if `a ?? b`?
      - means `a || b` from JS, which is just `a ?: b`
    - almost identical with `a&&b`
      + allows early returns as `a ?/ b;`, whereas `a && ^b` doesn't really work like that.
    - tiny profit, big discrepancy with convention

  2. Early return as `(a ?/ b; )`

  3. No special conditions, use `a && b`, `a || b`
    + no new syntax
    + all same perf benefits

## [x] Loops: look and feel ~~`i <- 0..10 <| a + i`, `i <- list <| a`, `[x <- 1,2,3 <| x*2]`~~ ~~`0..10 | i -> a + i`~~ `list |> # * 2;`

  * `for i in 0..10 (a,b,c)`, `for i in src a;`
  * alternatively as elixir does: `item <- 0..10 a,b,c`
    + also erlang list comprehension is similar: `[x*2 || x <- [1,2,3]]`
  * see [list-comprehension](https://en.wikipedia.org/wiki/List_comprehension)
  * ? Is there a while loop character, mb based on ternary? `a ?.. b : c`
    * or loop by secondary `a ? b :: c`
      - what if we don't need else condition? `a ?.. b;`
  * ? What if we simply provide short version of for `for (condition) statements`, augmented to `for(;;)`?
    * ? `for(let i = 0; i++ < x.length)`, `for (a in b)`, `for (i=0 < x.length)`
  * ? what if we even simpler do `a in b : a+1`, `i++ < x.length : a[i]++`?
    + it's like label but evaluable and returning to itself;
    + it's like `for`/`while` loop in form of operator;
    - it's like tail of ternary `a ? b : c : d`
      ? what about loop inside of a loop? `x++ < w : y++ < h : (x,y)`
        + yes, nested loops can be comma-defined `x++<w, y++<h : ...;`
    * ? or make label at the end? `(x,y) : x++ < w, y++ < h`
      + this is more classic math notation
      - a bit unusual and forces first step
      ~ math notation for loop is either `‚àÄA,‚àÉB:A<B` or `‚àÄ{x‚ààN,0<x<10},yx=x**2`
    * : is basically infix loop notation, compared to prefix `for a b` or `while a b`, or postfix `do a until b`.
    * ? `a :: b` ? `a <b>` ? `< a > b` ?
  * ~ from ABC notation loop is defined as `|: common |1 part1 :|2 part2 |`.
    * ? So maybe `|: i++ | i%3==0 :|`
    * ? Or `i%3==0 |: i++ :|`
      + separates repeating scope visually
      - double-character groups are slower to parse
  * ~ from UML loop is defined as `< i%3===0 > i++ : 0`, that can be done also as `{i%3==0} i++`
    * ? Or `i%3==0 { i++ }`
      + separates repeating scope visually
      + single-character group
  * ? modified ternary as `x in 1,2,3 ? a[x]=1 :|`, `i%3===0 ? i++ :|`
    * `a ? b :|`, `x = [x in 1,2,3 ? x*2 :|]`
      - mess at the end
  * ? `[ x in 1,2,3 :| x*2 ]` or the vice-versa `[ x * 2 |: x in 1,2,3 ]`
    + vertical bar is used in math notations: set builder, list comprehension {x‚ààR‚à£x<0}, {x‚ààR:x<0}
    + list comprehension uses | or : in many langs
    + `:|` is musical repeat indicator
    + `:` or `|` itself is not enough, it's too overloady or conflicting with ternary.
    + syntax space has no associations in languages.
    * `i%3 == 0 :| i++`, `a :| b`, `i++ |: i%3 == 0`
    a.`x < 5 :| x++`,  `x++ |: x < 5`, `[ x <- 1,2,3 :| x*2 ]`, `[ x * 2 |: x in 1,2,3 ]`
      + reminds label a: ...
      + keeps body visually clean after bar, as if returning result, condition clarifies body: `[x*2]` ‚Üí `[x*2 |: x in 1..10]`
      + `|:` sounds like `|` such `:` that, swoooch th th
        + matches set builder `x++ |: x < 5` as `x++ such that x < 5`
      - it subtly conflicts with elvis operator `x in 1..10 ?: body`, but `x in 1..10 :| body`
        ~ not necessarily - elvis has inversed intuition
      + `x * 2 |` is close intuition to standard list comprehension syntax
      + since condition is usually smaller than the body, `i ~= 1..100 :|` better indicates repeating part than empty line after condition
      + musically loop may have multiple ends and end mark `:|` place is uncertain, but `|:` is unambiguously at the beginning of loop.
    b. `x < 5 |: x++`,  `x++ :| x < 5`, `[ x ~ 1,2,3 |: x*2 ]`, `[ x * 2 :| x ~ 1,2,3 ]`
      + refer to looping body, not condition, which is better by musical intuition
        - it disjoints condition from repeating part. In music |: denotes the beginning of loop, whereas here it stands in the middle.
      + it matches elvis operator `x < 5 ?: x++`, `x < 5 |: x++`
        + muscle memory of ternary/elvis
        - it's not elvis by meaning: elvis does "else" branch, when condition is not true, whereas loop runs "true" condition.
      + has pipe operator intuition: by some condition produce the following `whileTrue |: produceItem`, `item :| whileTrue`
        + colon gives hint as "multiple" instances created on the right, following `|>` operator intuition
        ~ same can be said about `i ~= 0..100 :| x+=i` - multiple left parts are piped to right
      - often |: stands at the end of loop line, and looks like
      ```
      i ~= 0..100 |:(
        a++;
        b+=2
      )
      // vs
      i ~= 0..100 :|
      (
        a++;
        b+=2
      )
      ```
    - overall both of these seem a bit confusing and unclear, and do not stand nice with parens.
  * ? We can take almost purely math convention instead of objects `{ x < 5: x++ }` - procedural call
    ~- with same success can be used without {} - these brackets don't make much sense here only visually
  * ? We can take even simpler convention: { x < 5; x++ } - loops over until last condition is true.
    - do..until version, not much useful on its own. Can be used as combo with above.
  * ! `x < 5 -< x++`, `[ x <- 1,2,3 -< x*2 ]`
    + ridiculously hilarious and flowy from design perspective
    + `in` operator is literally in many languages just `i <- list` from list comprehension
    + `-<` operator is literally opposite of fold: for list comprehension formula it generates many items
      + and loop is no-array generalization
    + `-<` somehow reminds loop block from UML diagrams
    - it acts on "immediate level syntax space", whereas produces a bunch. There must be `|` for multiple items.
  * ! `x < 5 <| x++`, `[ x <- 1,2,3 <| x * 2]`
    + if we take `|>` as reducer, it becomes meaningful reverse operator: take one and produce many
    + visually it matches the meaning
    + it acts on "iteration" scope, which is nice
    - a bit false-match with reducer since reducer takes fn argument, but here neither left/right are arguments
      + reverse-function kind-of closes that gap `a |> b -> c`, `c <- b <| a`
  * ‚Üí ? `x < 5 :> x++`,  `x++ <: x < 5`, `[ x ~ 1,2,3 :> x*2 ]`, `[ x * 2 <: x ~ 1,2,3 ]`
    + result direction indicator
    + aligns with math, label reference
    + indicates "many" (by colon?)
    + less conflict with boolean in condition, (compared to |:?)
    + adds sense of flow
    + association with <> condition block
    - conflicts with F#'s :> operator
      ~ we don't deal with explicit types and don't use : in meaning of types
    - conflicts visually with leq, geq conditions: `a >= b :> a+b` - unnecessary direction vs `a >= b |: a+b`
  * ? `x < 5 <: x++`,  `x++ :> x < 5`, `[ x ~ 1,2,3 <: x*2 ]`, `[ x * 2 :> x ~ 1,2,3 ]`
    + meaning of <> block
    + musical reference |:
    + 1:M relation
    ~- conflicting with condition, but less than others
    - result direction is wrong
  * ? `x < 5 |: x++`,  `x++ :| x < 5`, `[ x in 1,2,3 |: x*2 ]`, `[ x * 2 :| x in 1,2,3 ]`
  * ? `x < 5 |> x++`,  `x++ <| x < 5`, `[ x in 1,2,3 |> x*2 ]`, `[ x * 2 <| x in 1,2,3 ]`
  * ? `x < 5 :> x++`,  `x++ <: x < 5`, `[ x in 1,2,3 :> x*2 ]`, `[ x * 2 <: x in 1,2,3 ]`
  * ? `x < 5 ..: x++`,  `x++ :.. x < 5`, `[ x in 1,2,3 ..: x*2 ]`, `[ x * 2 :.. x in 1,2,3 ]`
    + .. as intuition for "spread"
    + : as intuition for "comprehension/label"
  * ? `x < 5 ..| x++`,  `x++ |.. x < 5`, `[ x in 1,2,3 ..| x*2 ]`, `[ x * 2 |.. x in 1,2,3 ]`
  * ? `x < 5 ..> x++`,  `x++ <.. x < 5`, `[ x in 1,2,3 ..> x*2 ]`, `[ x * 2 <.. x in 1,2,3 ]`
    - similar to ..<, which means range definition
    + no visual conflict with ternary `a? b : c :> e`, `a ? b :> c: d`
  * ? `x < 5 --> x++`,  `x++ <-- x < 5`, `[ x in 1,2,3 --> x*2 ]`, `[ x * 2 <-- x in 1,2,3 ]`
  * ? `x < 5 => x++`,  `x++ <= x < 5`, `[ x in 1,2,3 => x*2 ]`, `[ x * 2 <= x in 1,2,3 ]`
  * ? `x < 5 -> x++`,  `x++ <- x < 5`, `[ x in 1,2,3 -> x*2 ]`, `[ x * 2 <- x in 1,2,3 ]`
    ~+ scala, ~+ elixir, ~+ erlang (~- not exactly them)
  * ? `x < 5 ::> x++`,  `x++ <:: x < 5`, `[ x in 1,2,3 ::> x*2 ]`, `[ x * 2 <:: x in 1,2,3 ]`
    + gives taste of .., : and direction.
    - too powerful blast
  * ? `x < 5 *> x++`,  `x++ <* x < 5`, `[ x in 1,2,3 *> x*2 ]`, `[ x * 2 <* x in 1,2,3 ]`
  * ? `x < 5 ~> x++`,  `x++ <~ x < 5`, `[ x in 1,2,3 ~> x*2 ]`, `[ x * 2 <~ x in 1,2,3 ]`
  * ? `x < 5 |:> x++`,  `x++ <:| x < 5`, `[ x in 1,2,3 |:> x*2 ]`, `[ x * 2 <:| x in 1,2,3 ]`
  * ? `x < 5 :>: x++`,  `x++ :<: x < 5`, `[ x in 1,2,3 :>: x*2 ]`, `[ x * 2 :<: x in 1,2,3 ]`
  * ? `x < 5 >:> x++`,  `x++ <:< x < 5`, `[ x in 1,2,3 >:> x*2 ]`, `[ x * 2 <:< x in 1,2,3 ]`
  * ? `x < 5 :>> x++`,  `x++ <<: x < 5`, `[ x in 1,2,3 :>> x*2 ]`, `[ x * 2 <<: x in 1,2,3 ]`
  * ? `x < 5 ?.. x++`,  `[ x in 1,2,3 ?.. x*2 ]`
    + intuition for condition and spread
    + reminds [..len] array creation, but [x in arr ?.. x*2]
    - doesn't play as nice with ~ instead of in: [x ~= arr ?.. x*2]
    - clashes/conflicts with `?.` - has nothing similar in intuition
  * ? `x < 5 ..? x++`, `[ x in 1,2,3 ..? x*2 ]`
    + semantic is close to punctuation combo
    + intuition for condition and spread
  * ? `x < 5 ?.. x++`, `[ x in 1,2,3 ?.. x*2 ]`
  * ? `x < 5 :? x++`, `[ x in 1,2,3 :? x*2 ]`
  * ? `x < 5 <?> x++`, `[ x in 1,2,3 <?> x*2 ]`
    + reminds UML <> block with condition inside
  * ? `x < 5 <:> x++`, `[ x in 1,2,3 <:> x*2 ]`
  * ? `x < 5 :.. x++`,  `x++ ..: x < 5`, `[ x in 1,2,3 ..: x*2 ]`, `[ x * 2 :.. x in 1,2,3 ]`
  * ? `x < 5 :: x++`,  `x++ :: x < 5`, `[ 1,2,3 -> x :: x*2 ]`
    + "array" intuition (many dots)
    + reminds : as in label
    + reminds math notation for list comprehension or set builder
    + reminds a bit musical meaning for loops
    - reminder of with Java/C's scope resolution operator https://en.wikipedia.org/wiki/Scope_resolution_operator
  * ? `x < 5 <> x++`,  `x++ <> x < 5`, `[ x in 1,2,3 <> x*2 ]`, `[ x * 2 <> x in 1,2,3 ]`
  * ? Do we need reverse direction? - Until is very rarely used, - until style is incompatible for list comprehension

### [x] loops can return a value: `(isActive(it): action(it))` - the last result of action is returned
  + useful for many loop cases where we need internal variable result.

## [x] Loops 2.0: since requirements are new, what's meaningful look -> `a..b |> do` and `..(i < 10)/0 |> i++`

  * `0..h |> (y,y1,y2)=(#,#+1,#+2)` doesn't look good in any form:
  * `:` defines branch, as in `a ? b : c`
  * we need named variable, using `#` in code isn't nice
    * naming will also emphasize the variable is local & cannot be overwritten as `# = 123`
  * `in` operator can be `a -< x..y` or `x..y -> a`
  * we need piping as `out[..] |>= oscillator[shape](phase) |> adsr(#, 0, 0, .06, .24) |> curve(#, 1.82);`
  * we need overwrite assignment
  * for functions we use brackets to indicate arguments `fn(a,b,c)=(code)`
  1. `from..to -> item : (code)`
    * `0..h -> y : ( (y1,y2)=(y+1,y+2) )`
    * ```
        out[..] -> s : oscillator[shape](phase)
          : adsr(s,0,0,.06,.24)
          : curve(s, 1.82)
      ```
    - confusable with arrow function as `0..h | x -> ...`
  2. `from..to | item -> (code)`
    * `0..h | y -> ( (y1,y2)=(y+1,y+2) )`
    * ```
        out[..] | s -> oscillator[shape](phase)
                | x -> adsr(x,0,0,.06,.24)
                | x -> curve(x, 1.82)
      ```
  3. `from..to |> x: (code)`
    * `0..h |> y : ( (y1,y2)=(y+1,y+2) )`
    * ```
        out[..] |> oscillator[shape](phase)
                |> x: adsr(x,0,0,.06,.24)
                |> x: curve(x, 1.82)
      ```
    + allows writes out
  4. `from..to |x> (code)`
    * `0..h |y> (y1, y2) = (y+1, y+2)`
    * ```
      out[..] |> oscillator[shape](phase)
              |x> adsr(x,0,0,.06,.24)
              |x> curve(x, 1.82)
      ```
  5. `from..to | x : (code)`
    * `0..h | y : (y1, y2) = (y+1, y+2)`
    * ```
      out[..] |: oscillator[shape](phase)
              |x: adsr(x, 0,0,.06,.24)
              |x: curve(x, 1.82)
      ```
    + qualifies as pipe, branch, range, named var
    + gives all benefits of `|:` operator
    + matches elvis short notation `?:` as `|:`
    + very short
    + nicely combines short form `|:` with named form `| x :`
      + allows unlimited loop form `.. |:`
    + `a..b | i: ` reminds label, which is cool
    -? rewrite is not the most elegant `a..b | i := c`
  !6. `from..to ? value;` - this will run branch as many times.
    + `from..to < 5 ? do;` - this will run from .. to
  !7. `x = from..to : do;`
    + no new operators
    + organically uses ranges
    * `y = 0..h : (y1, y2) = (y+1, y+2)`
    * ```
      x = out[..] := oscillator[shape](phase)
              : adsr(x, 0,0,.06,.24)
              : curve(x, 1.82)
      ```
    + pipe automatically rewrites x
    -? `x..y : a ? b : c` - is that `(x..y : a ? b) : c` or `x..y : (a ? b : c)`
    - not ideal pipe-write, eg `out[..] = i = out[..] : gen() : lp(i) : vol(i)`
      ~ pipe can be `i = out[..] : (gen(); lp(i); vol(i)) `
    - too similar to lambda fns: `fn = lambda x, y : x + y`
      ~ we really need inverted order as `x..y ~> x : x + y`
    - creates precedence riddle `a = b?c:d`, `a ? b=c : d=e`, `i=x : d`

  7.1 `from..to -> i : do`, `from..to => x : do` or `from..to ~> item : do`
    + `out[..] -> i : gen() : lp(i) : vol(i)`
      - `dest[..] = src[..] -> i : gen() : lp() : vol()`
    + reinforces notion of "element of"
    -? keeps `x = from..to` unused

  !8. `x < 10 ?? do;`
    + more natural while .. do than `..(x < 10) / 0 : do;`
    + includes "range" via two dots, kind of special range
    - introduces new confusable single-purpose operator, too much.
      ? Can we reuse ranges? mb a special range

  9. `x = from..to |> code` or `.. |> code`
    * `y = 0..h |> ( (y1,y2)=(y+1,y+2) )`
    * ```
      out[..] |> oscillator[shape](phase)
        |> adsr(%,0,0,.06,.24)
        |> curve(%, 1.82)
        |> dest[..]
      ```
      + follows natural assignment pattern
      + permits "stream to destination"
      + pipe doesn't look like a loop but applies classical pipe as `a |> adsr(#)` (one operation)
        + can even support placeholder like `%`
      + literally JS pipe proposal + ranges
      + doesn't reinvent the meaning of `:` & create clutter
      + easier to find-all loops, opposed to mixup of `?:` and `:`

## [ ] Arrays: Overwrite method

  1. `a[..] |>= _+1`
    - new operator
      - JS doesn't have it
    - doesn't allow conditional overwrite
    -? `=` operator likely puts elements to stack, at least sequences `(a,b,c) = (d,e,f)`
      - that means we're limited in cycling through
      ~ not for ranges though, ranges still work via heap
      ~+ nah, we should be able to do rewrite `a[..] = a[..] |> _` either way

  2. `a[..] |> _+=1`
    + no new operator
    + allows conditional overwrite `a[..] |> _ > 10 ? _ += 10;`
    - not obvious on long pipes  `a[..] |> _ + 1 |> _ += 2` - should it prohibit or ovewrite something?
    - new unknown pattern, can be unexpected

## [x] Arrays: to be or not to be? ‚Üí persistent fixed-size flat structures
  * ? what if we don't deal with arbitrary-length arrays?
    + it guarantees memory limitation, "embeds" into syntax
    + it removes much need in syntax around arrays like map, filer: it can be as `(a,b,c) | map`
    - that can be covered by groups
  ‚Üí ok, for map use groups `(a,b,c)(fn)` or `a,b,c | i->i**.5`
    . for reduce use `a,b,c |> fn` or `a,b,c |> a,b -> a+b`
    ! that is in fact mixing operator! a,b,c |> mix
    !? we can reduce based on reducer's number of args
  * I think we should overload these operators |, |>
  ‚Üí ?! Groups are flat, small and fixed-size; Arrays are nested and any-length.

## [x] Concat/flat groups ‚Üí no need to flattening/deep nesting
  * ?is done via range operator a, ..b, c..d, e (shortened spread)

  * ? destructuring is `a,b,c = ..d`
    - nah, just do `(a,b,c) = d`
    ? Alternatively: do we need nested structures at all? Maybe just flat all the time?

## [x] ~~what's the meaning of `>-`?~~ confusable with `a > -x`

  * must be the opposite-ish to `for of`.
  * for of takes each element from the list. this operator must take one element. Switch?
  * `1,2,3 >- x ? a : b : c` ?
    + switch operator
    + meaningful as `-<` counterpart
    + enables if-else as `1,0 >- x ? true : false;`
      . `1 >- x ? true`;

## [x] Switch: how? -> not needed if we have conditional return (br_if) operator, which is literally `a ? ./b` or `a ?/ b`

  1. `a == (1, 2, 3) ? (a+1, a+2, a+3)`
  2. `(1: a+1, 2: a+2, 3: a+3)[a]`
    + these work like labels
  3. `a ? ( 1 => 1, 2.. => 2, _ => ...)`
    + looks like rust
    + looks like kotlin
    + looks like Z notation
  4. `a ?= ( 1 -> 1, 2.. -> 2, _ -> ...)`
  5. `a ?> (1: a+1, 2..: a+2, _: a+3)`
    + makes sense of labels
    + combines condition `?` and go `>` (like pipe)
    - looks like terminal input
  5.1 `a => (1: a+1, 2..: a+2, _: a+3)`
  6. `a == (1: a+1, 2..: a+2, _: a+3)`
    + makes sense of labels
    + switch compares anyways
  6.1 `a ?= (1: a+1, 2..: a+2, _: a+3)`
    + makes sense of labels
    + combines condition `?:` and comparison `==`
    - commas define group - unclear how would you return a group
  6.2 `a ?= (1: a+1; 2..: a+2; a+3)`
  7. `a == (1 ? a+1 : 2.. ? a+2 : a+3)`
    + no new operators
    - contradicts to meaning of ternary
  7.1 `a := (1 ? a+1; 2 ? a+2; a+3)`
  8. `a ?: (1 -> a+1, 2.. -> a+2, _ -> a+3)`
    - commas don't make sense since it's for group
    - default condition can be undefined
    - elvis operator
  8.1 `a ?: (1: a+1, 2..: a+2, _: a+3)`
    - too many colons
    - elvis operator
  8.2 `a ?: (1 => a+1; 2 => a+1; a+3)`
    + we explore return operator as `=>`
    - elvis operator
  9. `a ::= (1 => a+1; 2 => a+2; 3 )`
    + backus naur form mixed with z-notation

  * So there must be improvement over
  ```
    a == 1 ? log(1) :
    a >< 2..4 ? log(2) :
    log(3)

    (
      a == 1 ? ./log(1);
      a >< 2..4 ? ./log(2);
      log(3)
    )
  ```
  * Essentially, it can be simply "return from current scope" operator, which in wasm is called "br" - break, or `../` / `./`
  10. `(a == 1 ?^ log(1); a >< 2.. ?^ log(2); log(3))`

## [x] Comments: ~~`//`,~~ `/*` vs ~~`;;`,`(; ;)`~~ ~~`//` is most based choice.~~ `\\` gives many benefits ~~`;;` has same benefits, but least toxic~~

  1. `;;`
  * Message: piezo is like assembly, expect low-level stuff & reading docs
  + ;; make more sense, since ; is separator, and everything behind it doesn't matter
  + `(;` makes more sense as "group with comments", since we use only ( for groups.
  + ;; is less noisy than //
  + ;; is associated with assembler or lisp/clojure
    + wasm
  + even simpler - everything after ; can be considered a comment?
  + doesn't introduce any new syntax space
  + it has "safe" or "light" semantic expectation, like, noone would guess it does something heavy
    + unlike `a \ b` or `a \\ b`
  - associates with autohotkey and other heavy scripts, which is the opposite of fast
  + associates with assembly langs and others: Most assembly languages, AutoHotkey, AutoIt, Lisp, Common Lisp, Clojure, PGN, Rebol, Red, Scheme
    + csound
  - single-comment breaks inline structures like a(x)=b;c;d.
    + that's why `;;`
  - not as "cool" as `\\`
  - `a + b;  ;; some comment` - not nice noise, compared to `// some comment`
  + more lightweight than `\\`
  + not confusable with `//`
  + no conflict with ANYTHING, very organic part of code
  + reminds `:` which is kind of cool for comments in typographics
  + more conventional than `\\`
  + Sercy sneezed
  + gives indication that the code is compiled down to wasm, wasm can even keep exact same comments
  + lisp, scheme, clojure, racket, asm style
  + clean & minimalistic, easier to read
  - `;; xxx` or `(;....;)` is valid actual syntax
    - eg. `sin(x)(; explainer ;)` is equivalent to `sin(x)()`
      ~+ kind-of equivalent to "nothing", eg. `x(a, (; some description;))` === `x(a,)`
    + `;;` code is discouraged
  + `;;` is safer & softer, not as spiky / scratchy, more familiar
  + looks the most organic for non-too-nerdy code, the most design-ish
  - `a();;;some action` - comment is detected at `a();;...` which produces invalid code
    - in other words, such comments are not so easy to strip
      ~ same problem is in C comments as `a///comment\nb`, way less frequently met though
  - conflict with direct code, eg. `(;;;)` is valid code piece, but comment will strip it out
    ~ that's an edge case, code like `(;;)` is discouraged
    ~ paired with `(; comment ;)` that's not a threat
  - the support of such comments is not widespread
  + hints to asm/wasm languages
  + if all programs use that comment style it seems fine: it's a good balance between neutrality, familiarity/intuitivity, innovation
  - it gives hand-made impression
  - `x()=(;a)` is SUPER common use case when first line is used for local var inits
  - `;;` has more in-code positional sense, not strong enough delimiter
  - `;;` is a nice pattern from `for (before;;after)`, we can use it for `;;defer` operator

  1.1 should we make comment an alternative to semi token `fn() ;;do something`
    + less symbols
    + nice alternative to simple semicolon
    - stripping such comments will break code
      ~ no need to strip, just replace to `;`
    - doesn't allow inserting inline comments within sequences like `a,;;xxx\n b`

  2. `//`, `/**/`
  * Message: piezo is like C / JS / Scala, expect similar intuition
  - // is noisy conflict with / and occupies operator space, eg.:
  ```
    tri(freq in 10..10000) = (
      ...phase = 0; // phase state
      phase += freq * pi2 / sampleRate;
      (1 - 4 * abs( round(phase/pi2) - phase/pi2 ));
    )
  ```
    ~+ it doesn't go without `;` so not so much conflict
  - // is used in python for floor division, very handy: (a / b | 0) -> a//b
    - not just floor division but autoconverting to int, which is super handy
      ? can that be resolved somehow?
      ~ what's the big deal of just a/b | 0? internally that's same, no?
    - it's just so nice symmetricity of ++ -- ** %% but not //
  - it blocks smoothstep as `-//`
  + ~~allows defer to be `\x++`.~~
    ~ we don't do defer via escape
  + // associates C+/Java/JS/F#, that's well-established
    + with many others: ActionScript, Boo, C (C99), C++, C#, D, F#, Go, Java, JavaScript, Kotlin, Object Pascal (Delphi), Objective-C, PHP, Rust, Scala, SASS, Swift, Xojo
  + ~~makes C#, F#-compatible syntax highlight~~
    - `(*p)` makes F# comment
    - `#p` makes C# comment
  + saves soooo much time converting bytebeats to lino
    + sooo natural to feel
    + maintaining syntax plugins is heavy task
    - can be without hardships converted to `\\`
  - search-matches with protocols like `https://`
  - pretends to be C/JS, when it is not.
    * Such comments would make sense if: code was case-sensitive; it had standard allowed chars (no #@); code had if|else|while|for|return|in keywords.
    + gives fresh feeling of old standard, since syntax is updated to be cool
    + and still it's like scala also
  - chances are // was unlucky choice in C, since for all basic arithmetics there's double + ++, - --, * **, % %%, & &&, | ||, but / // remains, as well as ^ ^^.
  - there's integer div in wasm, but no integer div in mel

  3. `\` or `\\`
  * Message: piezo is breaking new, but also weirdish like Julia, you gotta expect fancy stuff
  + mono lang reference
  +~ Forth?
  + \ is almost never used in langs & that's unique
  + reminds `//`
  - sort-of constant footgun to confuse with `//`
    ~ can be `\`
    - imagine mood of "let's have fun write some floatbeat" - you'd need to remember that difference from JS always
  - mental load to remember the comment style
  + it's short
  + association with "escape" sequence in strings
  - if strings come in (likely yes), then select-alling comments will select a bunch of escapes
    ~ can be `\\`
    ~ escapes are rare
    + doesn't conflict with JSy // comments on select-all
  - possible conflict with string escapes
    + can be resolved with `\\`
      + creates clear separation of "comments" area
    + `;;` can as well have conflict with strings, that's not a feature of this comment
      - string escapes are more likely
    + strings in JS/anywhere ignore comments
  + cooler than `;;`
    + `\` is cool
  + looks fresh directionally, shadow effect `\\\\\\\\\\\\\\\\\\\\\\\\\`
    + shadow makes sense as comments hide in "shadow" of real code
  - syntax highlighters don't know that
    ~ neither `;;`
    - maintaining all possible highlighters can be a lifetime effort
      ~ can be one-time vscode contribution
    ~+ not so heavy, can be done once
    ~+ existing highlighters don't know piezo anyways
  - takes primary semantic meaning, rather than "safe" secondary meaning
  ?- what's inline pairing?
    * `\* *\`?
    * `\ inline comment \`
      -~ prohibits-ish `\\ abc`, `\\\\\\\ abc \\\\\\\`
  - sometimes ascii art includes these - becomes cumbersome
    ~ can be `\\`
    + comments become part of ascii art which is cool
  - `\\`` is pessimist comment, // is optimist
    ~+ not necessarily bad: pessimistic note contrasts optimism of code
  + not confusable with http://
  + allows `-//`, `//` operators
    ~ we don't need them as much, `-//` is not best choice anyways
  - writing that comment by hand requires escaping each of these, so comment becomes `\\\\`
    ~+ just `\` is good enough
  - too ground-breaking
    ~+ maybe that's good
  - disturbs convention of C, JS, Scala, Rust, Java, Go etc
    - forcing all programmers from these lands learn that new comments syntax
  - complicates copy-paste of floatbeats
    ~ not so much
  - we're not creating language from scratch, we extend existing common syntax, and comments are standard part...
    + yes, but we are rethinking parts
    + besides it's a new language

  4. `/* */`
  + popular (CSS, C-family, PHP, Swift, Kotlin, Java, JS)
    -~ F# doesn't have these, although we can't use F# anyways due to `(*x)` issue
  + most conventional
  + allows removing newlines safely
  + supported by highlighters
  - too decorative
  - pair-operators are heavy to handle
    - editors don't use it as shortcuts as Cmd+/
  + space-agnostic, newline-agnostic: allows just removing all spaces from code safely, unlike `//` comments
  - not so nice without `//` pair
  - noisy
  - in JSX we anyways use that for comments

  5. `(; ;)`
    - wrongly associates with block
      - in fact valid block expression
      ~+ it doesn't make any sense to start block with `(;`
    + compat with wasm
    + everything is block-y anyways
      + that logic is from HTML comments logic: the most prominent language construct with special opening `<` + `!--` -> `(` + `;`
    + smiles ;)
    + allows easy strip
    + makes it space-ignorant
    + inlinable
    - without `;;` is not sufficient
    + hints that language is wasm-related

  6. ~~`{ comment }`, `{- comment -}`~~
    + Haskell like
    - reserves object syntax space

  7. `# xxx`
    * Message: piezo is like python - quirky, inlinish, unintuitive
    + Python, Perl, R, Raku, PHP, Shells, Ruby, Julia, Nim, Make
    - reserves `#` from the name, loop placeholder
    - too black, dark, heavy

  8. ~~`(* abc *)`~~
    + OCaml
    + Pascal
    - `(*p=2)` is phase state variable

  9. `'abc`
    + highlights as "string-ish"
    + refers to old vbasics: xojo, vbasic.net, vbasic, basic
    - strong association with strings
    - conflicts with apostrophes
  9.a ``abc`` - backticked
    + not as strong association with strings
    + not supposed to conflict with apostrophes or typographical stuff
    + looks like just unnamed strings
    + indicates possibility of multiline
    - too light for inline comments
    - immediate impression is strings within program

  10. `"Some comment about the code"`
    + unnamed strings can be used to store program comments, removed by compiler
    ~ can conflict a-bit-ish with compiler directives

## [x] Groups: what's that? -> just syntax sugar, not runtime construct like tuple

  * `a,b = b,a`
  * `a,b,c + d,e,f ‚Üí (a+d, b+e, c+f)`
  * `(a,b,c).x() ‚Üí (a.x(), b.x(), c.x())`

  ~ likely we have to swipe precedence of , over =
  . a,b,c = d,e,f       ‚Üí a=d,b=e,c=f
  . (a,b,c) = (d,e,f)   ‚Üí a=d, b=e, c=f          // destructured-assembled
  . (a,b,c) = d         ‚Üí a=d[0], b=d[1], c=d[2] // destructure
  . (a,b,c) = d,e,f     ‚Üí a=f[0], b=f[1], c=f[2] // destructure group on the right
  . a = b,c,d           ‚Üí a=(b,c,d)
  . a,b,c = (d,e,f)     ‚Üí a=(d,e,f),b=(d,e,f),c=(d,e,f)
    - contradicts to js intuition where only c = (d,e,f)
    + follows local meaning where members on the left get value from the right
  ‚Üí so there are 2 meanings:
    . () makes group a single component
    . , makes group, but separate components

  ~ group destructuring
  . (a,b,..cd) = (a,b,c,d) ‚Üí a=a,b=b,cd=(c,d)
  . (a,b,c,d) = (a,b,..cd)
  . (a,..bcd) = e ‚Üí a=e[0], bdc=e[1..]

## [x] Groups: always flat? yes, but loop accounts for number of args in mapper

  * It seems nested grouping creates more syntax confusion than resolves, like `..combs | a -> comb(a,b,c) |> a,b -> a+b`.
    - not clear if that's supposed to pass a group or a single value.
    . Nested structures better be solved via arrays.
  * Instead, groups can always do flattening, eg. `(a, (b, c), d)` === `(a,b,c,d)` === `a,b,c,d`
    + that would prove them to be just syntax sugar
    + that would make them lightweight like a cloud, without rigid type checking
      * sort of "fluent" type, existing on the time of syntax analyser
    + that would simplify fold / pipe logic, meaning they always get applied to each member `combs | a -> comb(a,b)`
    ? how to pass all group arguments to piping function? (a,b) | (a,b) -> a + b
      ? maybe extending fold operator to account for processor arguments? eg.
        * a,b,c |> a -> a * 2  ‚Üí  a*2, b*2, c*2
          - nah, following fold logic must return only c*2
        * a,b,c |> a,b -> a+b  ‚Üí  (a+b) + c
        * a,b,c |> a,b,c -> a+b+c ‚Üí a+b+c
          - unclear how to shift these args.
          - index comes as third argument usually
        ? it generalizes then as "convolve", where window is defined by number of arguments
          - not really: convolver doesn't fold signal
      ? or - loop operator with function may act as map
        * a,b,c <| a -> a*2
      !? or - we can pass all args depending on args count in pipe transform:
        * `a,b,c | a,b -> a+b` means  `((a,b) | a,b->a+b, (b,c) | a,b->a+b)`
        + yep. seems like a way to go,
        + establishes operator-overloading pattern
        + may act as convolver
      ? do we need index argument for pipe transformer
        - no, pipe is not mapper...
        ? how do we map arrays then
          * list comprehension: i <- arr <| i * 10

## [x] Groups: Assignment a,b=c,d -> let's use more familiar flowy JS style for now a=1, b=2 and force groups be scoped

  * lhs can only be ids, props or fn
  * lhs member on its own without assignment doesn't make sense other than in definition `a,b,c`
  * sequence of assignments `a=1,b=2` almost never makes sense - why, instead of just `a=1;b=2;`
    * only when we need a group and some members need to receive new value

  1. `a,b=c,d` is `(a,b)=(c,d)`
    + python style
    + allows shorthand nice swaps
    - problem with fn arguments parsing `(a=1,b=2) => `
    - unscoped groups make language a real line noise, very unusual pattern:
      ```
      y1, y2 = y+1, y+2;
      y1, y2 >= height ? y1, y2 = height - 1;
      ptr0, ptr1, ptr2 = y, y1, y2 * width;
      ```

  2. `a,b=c,d` is `(a),(b=c),(d)`
    + js style
    + more fluent imho
    + in sync with function arguments
    - forces group-assign be parenthesized (a,b,c) = (d, e, f)
      - which is extra keystrokes
      + that visually indicates groups better:
      ```
      (y1, y2) = (y+1, y+2);
      (y1, y2) >= height ? (y1, y2) = height - 1;
      (ptr0, ptr1, ptr2) = (y, y1, y2) * width;
      ```
        - maybe a bit too intensive grouping sometimes
          + but easier to understand what's going on
      ~+ in JS that's array destructuring anyways: `[a,b]=[b,a]`
    + allows comma-style operations sequence, rather than python-like meaning, eg a++, b+=2, c=4,
    + arrays are always scoped
    - in JS the meaning of comma isn't loaded with grouping, it's just sequence of operations
      - if you look at the code, it's oversaturated with () for grouping
        ~+ that helps visually identifying groups
      - sequence without meaning of group is needed only on declaration/args, but is mainly useless anywhere else
      - vars declaration can be as well done in Python style `a, b, c = 1, 2, 3`

  3. Single assignment is group, multiple is seq: `a,b = c,d` vs `a=b, c=d`
    + Allows unparented assignments `a,b=c,d;`
    - `a,b = c,d = e,f` - not allowed sequence of multiple assignments
    - `c=d,e` as return member or elsewhere considers only `c` as return instead of `c=d, e`
    - fn args `(a,b=1)` makes it as `a,b = 1` vs `a, b=1`

  4. `=` balances number of left/right members, `a,b=c,d, e=f, g,h,i=j`
    ? `a,b,c=3` in fn arguments?
      + can throw error on unbalanced assignments
      +? to assign one value to multiple targets, use grouping `(a, b, c) = 1`
    - `a, b=1` declaration - is that `(a,b)=1` or `a, (b=1)`?
    + can be the case of assignment only, any other ops require grouping `(a,b) + (b,c)`
      - creates confusions in code - some parts are grouped, others are not - forces knowledge of precedence
      - it can be pretty high: `x1, x2 = y1, y2 * 2` - what'd you expect here?
    ~ y1, y2 = y+1, y+2; // ok, since sequence doesn't make sense here
      y1, y2 >= height ? y1, y2 = height - 1; // hmm
      ptr0, ptr1, ptr2 = y, y1, y2 * width; // which y gets multiplied here?

  5. one-member requires group `a, b, c=1` / `(a,b,c)=1`, but multiple can be flat `a,b,c = 1,2,3`
    + separates group op vs group visually
    - `fn(a,b,c=1,d,e)`

  5.1 stack-balancing `a,b,c=1` is `a, b, c=1`, `a,b,c=1,2,3` is `a=1, b=2, c=3`
    ? mb based on number of lhs-idables
    + to make single-assign do `(a,b,c)=1`

## [x] Groups: Raise `,` precedence? -> nah, let's keep groups scoped

  - not having `()` around sequence can be misleading, `()` visually outlines group
  + `^ a,b,c` ~~`a,b,c.` - naturally done via `x ? a,b,c .` operator~~
  + ~~`a,b,c |>`~~
    + `i = a,b,c : x()`
  + ~~`a,b,c -> a,b,c`~~
    * we don't have arrow function anymore
  + `x ? a,b,c;`
  - `*a,b,c, d=1` vs `*(a,b,c), d=1;`
    - `*` elements cannot be part of sequence
  * generally `,` can be above all operators which cannot be part of group, eg. `^(a,b),c` is impossible

## [x] Groups: ops - how? deconstruct to per-component ops with duplication

  * Must not introduce any dynamic tax

  1. Simple members: deconstruct to component ops
    * `(a,b) >= h ? (a,b) = h-1`
    * `(a>=h, b>=h) ? (a=h-1,b=h-1)`
    * `(a>=h ? a=h-1, b>=h ? b=h-1)`

  2. Complex multiple members: write to heap and multiply from it
    * `(x ? a,b : c,d) * (y ? e,f : g,h);`
    * `(... (x ? ^ a,b); ...; c,d) * y();` - where y returns multiple values also
    * `(a <| @) * (b <| @);`

## [x] Convolve operator? -> let's try to hold on until use-case comes

  * Fold operator gives thought to convolver operator which slides window depending on number of arguments,
    samples ^ (a,b,c,d,e) -> a*0.1 + b*0.2 + c*0.4 + d*0.2 + e*0.1 returns all same samples weighted with a formula
    - can be too hard for big kernels
    - debases point of arguments spread: `samples ^ (...kernel) ->` - what's supposed kernel size?
      ~ we not necessarily support args spread
  * Pipe can be used as simple convolver (see above):
    * `a,b,c | a,b -> a+b` means  `((a,b) | a,b->a+b, (b,c) | a,b->a+b)`

## [x] Variables: Notes as hi-level aliases for frequencies A4, B1 etc. -> available
  * import 'musi' - imports all these constants
  + allows building chords as (C3, E3, G3) = Cmaj
    ~ would require # to be valid part of identifier

## [x] Functions: erlang-like `x() = a; b; c.` -> let's use `x() = (a; b; c);` for now

  * [erlang functions](https://www.erlang.org/doc/reference_manual/functions.html): they use only `;` and `.`
  + allows no-block syntax

### [x] Variables: blocks: {} vs () -> `()`

  . {} feels somewhat movetone.
  . block basically needs limiting variable scope, it doesn't have sense on its own.
  ‚Üí we can make () a block if that includes variables definition, otherwise not.
  + we may require block if new variables are defined, else args must be used.
  + () makes warmer inside, sort of nest in literal sense.

### [x] Variables: declaration within scope `(a;(a=0))` vs `((a=0);)` -> defined per fn body like python

  1. left defines first-level variable and modifies it within second scope, right - creates second-level variable
    - makes parens affect vars visibility, eg `((a);(a=0))` loses variable
    - makes code logic sensitive to presence of parens, ie parens are not transparent anymore (same defect as state vars defining fn scope)
  2. all variables are declared per fn body scope
    + in-sync with static variables
    + in JS that's common practice how it's done - one declaration block, rest is just reuse of vars
    - cannot shadow globals, so the code is still sensitive to presence of global variables, some global names can affect logic

### [x] Variables: coming together -> globals are read-only, writes define locals

  * we need special assignment precedence only for declarations, everywhere else that's group `a,b,c = d,e,f`
  * declaration would allow us to secure scope - make it independent of global
  * there are variable kinds: const, ui, var, state
  * v128 cannot be used as global or as fn return

## [x] Inlining / Mangling / compressing

  * language should not break inline composability, like it does python or livescript: you can tightly pack code into a single line.
  * language should be mangle-able, therefore names should not have prefixes
    ~ mangling can recognize that
  * Spacing material should not have any syntactic meaning, like JS does for newlines. `;` should be a default separator.
    * what if we detect next expression as next unrelated operand, regardless of separator?
    - nah, too much noise.

## [x] Functions: How do we map various clauses to wat/wasm? ‚Üí ~~`allocBlock` function, untyped (f64 by default), see audio-gain~~ we don't use clauses

  1. fixed pointers and `fn(aCh, bCh, ..., x, y, z)`
    - harder to manage variable number of inputs
    - needs mem layout convention
    - no way to differentiate i32 from f32
  2. `fn(aPtr, aCh, bPtr, bCh, ..., x, y, z)` - pairs reflect a-Param, single value reflects k-Param
    - may have conflict number of args, eg. `gain(xPtr, xCh, amp)` and `gain(x, ampPtr, ampCh)`
  3. Combining flags for a-rate params? (or k-rate params)?
    ```
      enum {
          A0 = 1 << 0,
          A1 = 1 << 1,
          A2 = 1 << 2
      };
      fn(A0|A1|A2, aCh, bCh, cCh, x)
    ```
    + Can act as single binary simply as `fn(0b1110, aCh, bCh, cCh, x)`
    + Most compact form (simple enum)
    - there's no binary literals in C/C++
  3.1 Integer? Hex literal? For types?
    + `fn(0xaaacc)` indicates 3 a-params, 2 c-params (controlling)
    - limited to max 16 inputs 0xFFFFFFFFFFFFFFFF
    + extensible, allows 16 types of input arguments
      * ? clamped (-min/-max)
      * ? step
      * ? a-rate, k-rate, ...
      * ? i32, i64, f32, f64
      * ? interleaved / planar
      * ? L128, L256, ... L8192
  3.2 Hex for number of channels?
    ~ to destructure input `gain(0x20,inPtr,b)` ‚Üí `gain((l,r), .5)`?
      - redundant-ish pointer
    * ? maybe reflect memory layout, instead of pointers?
      + 0 = no block, 1 = 1 block, 5 = 5 blocks etc: `gain(0x20, #, gain)` means 2 blocks for 1st arg, 0 blocks for gain.
        ? what is placeholder then? pointer? number of channels to destructure? clause indicator?
  3.3 Hex for clause indicator? `gain(0x1)`
    * same as just 3. The point is enriching indicator with meaning.
  3.4 Hex indicates type of args, args indicate memory layout or values.
    * `gain(A0_F32_PLANAR | K1, 2, .5)`
      - too many combinators A0, A1, K1 etc.
  4. Per-channel modifiers `gain(2|A|F32|PLANAR, .5)`
    + less modifiers
    + reflects memory layout
    + readable
    + unlimited number of channels
    - same as in 1.: hard to make difference of f32/64 vs i32/64.
      ~ unless we make mandatory marker, eg. A_RATE or CHANNELS or INPUT or any actually, which sets hi-bit indicator of aParam case.
    ~ we can even pass mem pointer with modifiers, i64 allows to fit everything.
      ? `gain(2-ch, .5)`, `mix(1-ch, 2-ch, 2-ch, 2-ch, gain)`

  ‚Üí God would like it something very very simple, with sane default.
  ‚Üí These modes need to be exposed by wasm to not depend on wrapper
    - wasm doesn't directly expose constants. Seems that we have to make a userland convention. `MEM = 0xf000` etc.
      ~ they actually give number by `valueOf` call, ie. operations with them are workable
    + that convention allows naming that factor the way user prefers - CH, CHAN, CHANNEL etc.

  4.1 Mult operator is more conventional `gain(2*ch, .5)`, `mix(4*block, 2*block, 2*block, 2*block)`
    -~ ideally channel variable has numeric meaning on its own
    ? - `gain(MONO, STEREO)`... nah

  5. We reserve integers for channel pointers, floats for params.
    ~+ is there ever cases when we need int values for params and not floats?
    + ints are better at addressing memory etc.
    ~ we're again at 1, but not with pointers but memory allocations.
    - ok, null-indicator is confusing in frontent also.
    - besides, we can't indicate F64/F32, which can be useful as well.
    ‚Üí so better we do 4 or mix of 4 and 5 `process(2 * blockSize | MEMORY, .5)`

  ‚Üí Memory also must be declared by WASM, not imported.

  6. Reftypes.
    + allows thinking not about mem allocation and just pass values as is, but
    - has very little info on what to do with these reftypes
    - to bring any meaning, requires strapping - nah
    - binds to JS

  7. `gain(2|IN, gain, 2|OUT)`, `gain(2|IN, 1|PARAM, 2|OUT)`
    - float params cannot have flags: we have to write values to memory then.
      ~+ maybe that's better since it detaches memory from code. For example, shared memory can be independent.
    - we cannot indicate clamping limits
      ~ not necessary we're going to need them - we can compile them into source, which is better

  7.1 `gain(input(2), gain, output(2))`, `gain(input(2), param(gain), output(2))`
    + nice look
    - combining config is not aesthetical
    ~ output can be skipped
  7.2 `gain(aParam(2), kParam(1))`
    + allows defining limitations: `gain(aParam(2, -1, 1), kParam(1, 0, 1))`

  8. Configurable static layout: `setBlockSize(N), setMaxChannels(16)`
    * that recalculates `INPUT_PTR`, `OUTPUT_PTR`, `INPUT_LEN`, `OUTPUT_LEN`, `BLOCK_SIZE`

  ‚Üí It should be simple and soft, like a breeze.

  9. `[ptr, size] = param(channels)`, `blockSize` is configurable global
    + this is simple
    + this is like 7.2 with pointers
    + this allows space for extra args to param constructors, like clamping etc.
    * ? maybe we better off `[ptr, size] = aParam(2)`, `ptr` = kParam(2)
    ~ identifying slot params by ptr would require internal state. Ideally we keep it simply as calculation:
      * gain(a,b,c) whould know nothing about params, it should really be isomorphic and calculate based on args, that's it.

  ‚Üí block size may change over time, so better reserve place in-advance.
  ‚Üí just follow [audioWorklet.process](https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor/process)

  10. Ok, proper way is alloc or array (see @audio/gain.wasm)
    * [Simplest malloc](https://github.com/rain-1/awesome-allocators)
    * [Array](https://openhome.cc/eGossip/WebAssembly/Array.html)

    10.a ‚ú± `inptr = allocBlock(2); outptr = gain(inptr, gain)`
      - allocated memory cannot be reused by another number of channels
        ~ that region can be read though
        ~ that can be undesirable practice to reuse same memory for different arg types
      + can store information about number of channels in this slot
        * memory at pointer should have a flag for clause selector to quickly check if that area is block
      + signature matches directly function arguments
      - not passing blockSize as last argument makes direct non-batch call return single value.
        ~+ direct calls have nothing to do with block size - we don't pass blocks as args to them.
    10.b `malloc(2*blockSize); gain(inptr, 2, gainptr, 1, outptr, 2 )`
      + allocated memory can be reused for various channel numbers cases
        * eg. `gain(x)`, `gain((l))`, `gain((l,r))`, instead of `gain(leftPtr, rightPtr)`
      - k-param turns into `gain(inp, 2, gainp, 0, outp, 2)`
    10.c `malloc(2*blockSize); gain(inptr, 2*blockSize, gainptr, blockSize, outptr, 2*blockSize )`
      - number of channels calculated runtime, which is not apparent
        * ie. mapping of arbitrary sizes to arbitrary other sizes is not clear
      + can indicate exact number of samples, which is sort of convention [ptr, len]
        - length is stored by allocator
          ~ implicit remembered state isn't nice
      + conventional (ptr, length) pairs
      + allows reusing same memory for any number of channels
      - signature calc is complicated-ish
      - keeps redundant out size, which is apparent from the source
        + in fact can be used to check available size
      - inconsistency of pointer and blockSize units: pointer measures bytes, blockSize measures items
        ‚Üí either alloc should return units pointer, or require allocating bytes and not items
        . if we allocate items, it really better be array, or slot, or something more hi-level
        . or else use direct trivial malloc, but then the signature and implicit channels problem remains
          - the original task doesn't correlate much with malloc purpose: memory can be managed memory.grow easily.
          . maybe indeed we should better stick to param kinds convention instead of generic forms
            - we still need to pass channels info somehow: slot size can fit more channels if blockSize lowers
    10.d `malloc(2*blockSize); gain(202, inptr, gainptr, outptr )`
      + saves time calculating signature client-side
      + less arguments
      - signature can be limiting to max 10/16 channels
      - signature is too lengthy
    10.e `malloc(2*blockSize); gain(inptr, gainptr, outptr, 2, 0, 2)`
      + keep args order similar to descriptor
      + breaks ptr-size convention
      + allows optional last arguments (output is internal, gain is 0)
        `gain(inp, gainp, outp, 2, 0)`
      + easier to calc signature
      + (possibly) less internal calculation - no need to detect number of channels from mem layout (implicitly as in 10.c)
      + no need to deal with 1-value krate inputs calculation, as it's directly indicated
      + direct values fn clause can be detected by 0 arguments
      - there's no clear understanding how k-param or 1-channel a-param maps to multiple channels
        * seems that notion of channels and k/a-rate are different
        - detecting a-/k- rate implicitly from memory size of pointer is not necessarily good
        ~ can be facilitated by [channels interpretation](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Basic_concepts_behind_Web_Audio_API#up-mixing_and_down-mixing)
          * neither speaker nor discrete: only copies mono value to all channels, else - discrete.
          ~ maybe we don't need absolute flexibility: if you need precise per-channel values, just provide full a-rates.
      - redundant arguments; we can store them in pointer itself.
    10.f `gain(inptr, gainptr, outptr, 2|A_RATE, 1|A_RATE)`
      - requires const imports
      - too magical
    10.g `inp = aParam(2), gainp = kParam(1), outp = aParam(1), gain(inp, gainp, outp)`
      - if we bind param to memory slots, we cannot reuse it for more channels
        . therefore channels must be detected from gain input params
        . therefore holding structure must be linear array, or slot
    * memory can store last available item in global variable
      + allows manual memory management
      - doesn't allow sharing memory easily

## [x] Autogenerate mono/stereo clauses fn code or define fn clauses manually in syntax -> ~~autogenerate~~ manual

  * See [gain node](https://github.com/mohayonao/web-audio-engine/blob/master/src/impl/dsp/GainNode.js) for clause examples.

  1. autogeneration
    + makes son code shorter
    - generates n^2 codebase, very redundant and prone to uncontrolled growth

  2. manual clauses
    + reflect "hint" to how much code is generated in son source
    + more precise
    - can be tedious for long processors
      ~ maybe long processors should fallback to core routine, for example
    + clauses allow defining pipe-input case
    + that's nice that clauses are turned on only if defined, not otherwise

  ‚Üí prob there's no sense to generate internal fn clauses, unless overload takes place

  ‚Üí there's no much sense generating looping functions for internals.
    * for exports we create clauses = that depends on the way fn is called.
    * so that's just generalized way to "batch" functions against values in memory.

  3. Rethinking. Since we don't allow overloading and external batch argument is explicitly defined via `~`, we can autogenerate function code for simple mono & stereo cases automatically.
    + doesn't enforce array destructuring
    + saves lots of manual code
    + saves namespace

## [x] ? Should we provide param types or not? -> ~~try explicit dims notation `[1024]in`~~ -> nah, can pass ptr directly
  * kParam type clause can save 1024 memory reads per block.

  1. hide implementation detail of kRate/aRate and generate both clauses depending on input type.
    - see zzfx: myriad of params generate O^2 clauses. A mess.
      ‚Üí we need some indicator of param type
  2. generate params via typescript-like syntax `param: kType`
    - colon is too ambiguous
    + very common: rtype, hegel, flow use same notation
    - needs separate type parsing/tracking subsystem, whereas name immediately reflects type
    + allows multitype definition as `frequency:aParam|kParam`
      + this solves redirection problem
    - types are reserved words, we have policy of 0 reserved words
    - conflicts with other cases of colon, like condition or named args
  3. use csound-like prefixing for identifying params: ifrequency, ainput, gi
    + melds in global params organically `gTime, gSampleRate` (which is glsl-familiar)
    + name reflects type constantly
    + shortness
    - problematic destructuring of multiple channels: gain((al,ar) in -1..1)
      ~ can be mitigated by default params falling back to a-type `gain((l,r) in -1..1, kGain)`
      ~ destructuring could be prohibited
        ~ but we need that for indicating simple layout cases `l,r` vs generic-channel case `..ch`
    + resolves conflict of fn name and param: gain vs kGain, delay vs kDelay
    + that also works good as indicator of non-argument variables
    ~ ? should non-prefixed params possibly generate two versions?
      + default params better be direct fn values (helps problematic defaults case), prefixed - for batch
    - unclear how to redirect a-param clause to k-param
      ? name multiprefixed as `akVolume`
        + csound's gi proves for this case
        - ? how do we make direct param, aParam and kParam altogether?
          ~ we don't necessarily need that for the case of dsp instance: direct params are for direct functions.
      + not sure if we necessarily need that. WAA doesn't have that, it's web-audio-engine invention.
        + it also complicates detection: disables kParam to have multiple channels also makes constructor require param type.
          * just use a-param if you need accurate/per-channel values.
      ~ in this case we can assign a-prefix to audio params, and k-prefix for all else
        + accurate params supposedly come first
        + k-rate params may not need channels or could even be direct...
  3.1 We can assign a- prefix for a-params, discard k-params as direct values
    + allows getting rid of `dsp` prefix
    + solves historical problem of k-param naming (no need for k prefix)
    - `ax` instead of `x`, `aInput` instead of `input`
      ~ not necessarily bad - `a` prefix is good indicator of channel-read.
    - some functions are dsp with 0 params: like songs, fully uncustomizable

  3.2 Instead of prefixes, we can demand channeled inputs be explicitly indicated as
    `gain((l,r), amp)`, `gain((l), amp)`, `gain((...ch), amp)`
    + very explicit difference and logic
    - `...ch` is non-conventional operator, it's used for state recovery, not args destructuring
      * ? what if we use range instead `gain((0..16), amp)`
        - numbers are meaningless, not clear how to iterate non-numbers
        - fixes to some particular number of channels, we need unbound
    * see 7

  4. `amp as kParam`
    + same as 2
    + no destructuring issue
    + more human-readable
    - longer lines, ~ although not much longer than colon
    - mb conflicting with `in` keyword

  5. GLSL, C-style `gain(kParam amp in 0..1)`
    + nicer style than comma operator
    - doesn't allow multiple types

  6. Since we need main function to be exported, we can build clauses only for it, automatically.
    + no param type headache and even notion
      + no question of redirecting a-clause to k-clause
    + easy internal functions interchange
    + automatic management of global time and index
    - still myriad of clauses for only zzfx

  7. what if we use unclosed range `gain((..ch), amp)`
    + matches array allocation `[..16]`
    + similar to args collecting `fn(...args)`: intuition is `[..args]` - spread args or create from range, `(..args)` - collect args...
      ? + then matches destructuring as `(a,b,..cd) = (a,b,c,d)`
    ? how do we redirect channeled input to non-channeled (k-rate)?
      ‚Üí direct clause gain(v, amp) or channel clause gain((..v), amp) is detected statically
      ‚Üí internally they're used as direct case, not batch.
        - that would require direct case compilation or sort of special internal batch call
    ?~- is that just clause indicating layout?
      ? is there an exported API case when this is used directly, not as batch?
        + for multi-channels we'd need some memory layout anyways, batch is just natural extension.
        ~‚Üí we can pass blockSize as last argument - compatible with other DSP frameworks.
          + which allows avoiding blockSize global.
            ~- we'd going to need to take sampleRate argument as well then.
              ~+ not necessarily: global sampleRate can be useful itself
    - mixes up either with groups definition or

    8. * use `~` as indicator of input or output?
      * `gain(~input, amp)`, `gain(~[left, right], amp)`, `fn() = ~[l, r]`, `fn() = ~channels`
      + looks cool as indicator of expected waveform `~` as input or output
      + can better indicate `~in` as list of channels, rather than exceptional `[..in]`
      - `~` can be unnecessary if returning input variable: `gain(~in, amp) = in * amp`, `gain(~in, amp) = ~in * amp`
        ~ (can be fine, it's just an indicator of batch)
      - preliminary return mess: `gen() = (cond ? ^~[l,r]; ~[l,r])`
        ~ doesn't have much meaning by itself, out is supposed to be batch-variable.
        ~ can be rather an exception, expecting variable to be defined a bit in advance
      * `gen() = (~out; ...fill up out...; out)`
        - can mess with state `(~*out)`, `(*~out)`
          ~ stateful by default, stores result of last processing anyways, so that's just `(~out)`
        - not clear at first what to initialize this variable to - list of channels or a single channel
          ~ can do `(~[l,r];...)` or `(~chx;...)` same as input
            - unclear the total number of channels in `chx`. Max?
              ~ Maximum limits processing capabilities (can be configured)
        + maybe that's better to explicitly initialize output here indeed, since that's returned from function via API as block
        - conflict with binary inverse (NOT) `~a` vs declaring a batch variable.
          ~ NOT is used in expressions after _number_ declaration, wheres channels is only in declaration and not in expressions;
        - dissonanc-ish with `a ~> b` and `a <~ b`
          ~ these two are not stabilized yet
      + matches `.`, `*` paradigm
      * `~gen() = (out)`
        + simplifies output type indicator as block.

## [x] How to differentiate a-param from k-param argument -> no fn overloading

  * There's no way to differentiate gain(channels, aParam) and gain(channels, kParam).

  1. `offset = block(n)` offset can be float, which works for `typedarray.set(data,offset)`, as well as indicates kParam type.
    * ? Only takes finding out "impossible-ish" fraction values.
      * we can export that "key fraction" turning argument into offset as global
      * ? What if fraction reflects actual offset? Eg. 1234.0000004321
        - nah, that increases possible fractions
      * Consider also main part must be one of limited set of addresses.
      * Suppose different orders encoding reduces chance. Eg. `1234.1112340000000114321000000111234`
        * Similar to passwords encoding: more concepts engaged the better.
          + order gaps
          + static part of a key (11)
          + replica of a key (1234)
          + reflection of a key (4321)
          + ? sum of a key
          + https://en.wikipedia.org/wiki/Luhn_algorithm ?
        * Each this check reduces chance of matching offset with random input argument.
    - That's too shaky
  2. Export under different names: gain_a_k, gain_a2_k, gain_a1_a1
    + no conflicts
    + no perf tax
    + scalability (say, another input argument type)
    - Exporting all these names pointlessly increase module size
      ~ insignificantly though
    - `k` isn't real k-param, it's simple argument.
      ~ can be done as real k-param
  3. `[inputId, inputOffset] = aparam(n); process(inputId, ...args)`
    - decouples inputId from inputOffset: can be not obvious what passing id means.
  ‚Üí 4. Prohibit overloading functions?
    + removes ambiguity
    + simple solution
    + all pros from 2.
    + solves this issue completely
    + doesn't enforce artificial naming convention
    + argument doesn't drive function clause
    - it complicates `curve(input, param)` and `input | curve(param)` case.
      ~ either we introduce pipe operator `input |> curve(param)`
        + less code (no need to define pipe fns), + less need in arrow functions, + less overloaded operators

## [x] `t`, `i` are global params? Or must be imported? Or per-sound? -> manual time management

  * ? cannot be imported since generally global-time t/i are unknown. Mb defined as `...t as time`?
    - try avoid typing
  * ? or `#t`
    - try avoid too magic
  * Sound can be called multiple times, so timer per instance makes sense.
  . Time doesn't make sense as external parameter, since user cannot modify it, it flows forward, like state:
  . it has init moment and increases over time, not necessarily steadily.
  ? add specifier to initializer as `...t=0 as time, i=0 as index, rate as sampleRate`
  * ? may we need access to current time / index params of a particular instance?

  * floatbeat & co pass only `index` param called `t` - meaning depending on sample rate can be modified any way.

  * ? adsr may be called multiple times within same song, and it has internal t param.
  * that is also useful to any sound function basically, so we need per-fn time param. How?
    a. `t` as local param. adsr(t, a,d,s,r)
      + standard notation
      - redundant code
      - conflicting with batch runner: first argument doesn't necessarily have meaning
    b. `t` as implicit fn param, taken as `gt` by default. adsr(a,d,s,r), adsr(a,d,s,r, #t=0)
      + like context, but may pass multiple implicit variables
      ? mb acts as css
      + "gates" reserved keywords, allowing prefixed reserved names
      + plays well with #in as input from pipe operator
      + prefix allows implicit arg come in any order
      + allows passing "reset" param
      - still redundant code: passing param here and there is mess
    c. `t` as part of function state, which is defined as `...t`, eg. `...t as time`
      + more explicit definition
      + naturally reflects number of times this fn was called
      ? how do we expose that? do we need to expose that?
      + plays closer with stateful definition
      + time is usually relative, so it's rather internal for a function...
      ~ we then need means of resetting it
        1. new fn()
          - looks like class
          - resets too much
        2. [process, reset] = Gain() (~hooks)
        3. reset manually by condition eg. if (x>100) x=0.
    d. `sync` keyword? meaning time is synced with time of caller.

  * time management is easy part. It can trivially be done within function itself: `...t=0, t++`
    + avoids complexities of implicit params, function context, special timely batch etc.
    + floatbeat is just t === index.
    + unleashes batches to any function

## [x] Instantiation of sound ‚Üí no instantiation, use function state for manual tracking time/params.

  1. ? Instantiate sound externally via module instance?
    + resets and tracks globals per-environment
    + naturally very simple API, no constructing complications
    + t,i,sampleRate etc. params are accessible globally
    - any exported function iterates i, t params === makes single processor per instance
      - we need multiple processors exported, eg. latr library - should be useful itself.
        ~ not necessarily. Sonr can be relatively isolated thing and provide single export on build of a single processor.
          + that reduces number of generated codebases.
          + that complies with AudioWorkletProcessor - one instance per audio node.
      ‚Üí there must be context per processor
        ‚Üí context can be done as module instance
    * 290ms for 30k instances - comparable with subscript parser.
      - slowish for just instancing
    - still needs some convention for "main" method
      ~ can simply be "last function is result of module", like last expression in function
        + that builds nice structuring convention for all son programs - user knows where to look up for main processor.
        -? what if last item in module is not a function, but eg. global?
          - it returns global then and not processing function...
    + doesn't have problems with collecting old instances (gc covers that)
      + doesn't grow memory within processor
    - channel case selector is part of processing function
      + makes JS API simpler: only provide channels for a-params
    ~- exporting single method makes module unusable by other modules, eg. we can't redist songs and stick to main function convention.
      - main export function is no different from any other t-dependent sound producing function.
      ~ ok, hooks-like state allows thespassing this limitation

  2. ? Or take `t`,`i` as param?
    * We may need to call same function with different time within same sound.
    ? Should it be implicit-default-function param, like `f(#t=gTime)` and to call `f(a,b,c,#t=localTime)`?
      + ? this can also be used for pipe input as `f(#input)` or...
    - it would require manual time management...
  3. ? Or have `main` method?
    + reset t, i, similar to subscript.
      ? does it imply some main method iterating `idx, t` values?
      ? or that implies some init/config method, sort of csound orchestra definition below?
        - doesn't provide automatic iteration.
    + allows orchestra definition
    + `main` name: C, GLSL, C#, D, Go, Haskell, Java, Python(ish), Rust
      - mathematical name `f` is shorter and nicer, less descriptive though
      - in JS default has more meaning.
  3.1 JS has `default` export convention available.
    + invites to rename to any fn name: `main`, `gain`, `process` etc.
    + if not occupied leaves `default` hanging
      - not necessary, since importing wasm is not yet part of ES

  4. default function acts as config, returning main processing function
    * ~ webassembly allows returning funcref result, meaning - functions can return functions
    * `let gain = createGain(sampleRate: 44100, 0dbfs: 1)`
      + it can even return array as `let [gain, reset] = createContext(sampleRate, 0bfs)`
      - not necessary to have default
      - redundant structuring: sampleRate can be global
      - there really can be various "processing" entries

  5. we can have a special keyword indicating processing nature of a function.
    * ? make all exports processors?
      - no, we may need to reuse other non-processing functions
    * ~ `process gain() = `
    * `channels gain()=`, `block gain()=`, `audio gain()=`, `bulk gain()`
    * `batch gain()=`
      + literally meaning of `https://en.wikipedia.org/wiki/Batch_production`
    * `produce gain()=`, `producer gain()=`
      - not necessarily producer, can be filter or processor
    * `prod gain()=`
      ~+ production.
    * `gain...() = `?  `gain()... = `?  `...gain()=`,  `*gain()=`,  `gain*() = `
      - too mysterious and not clear
    * `[gain]() = `? `gain[] =` ? `gain[..blockSize]()`
      + Square brackets indicate block, as for "array" processing
    * `signal gain()`?  `sig gain()`?
    * <3 `dsp gain()`?
      + signal, processor on their own is not enough, dsp is stable known acronym
      + short, known, standard-ish, has meaning "digital signal processor"
    * `through gain()`? `gen gain()`? `dest gain()`? `pipe gain()`?
    - it's still not enough for instantiation: what if we export multiple processors? they all would share same time therefore could not be reused.
      - creating module instance per processor is overkill-ish.

  6. Capfirst function = DSP?
    + resolves processor/param naming conflict `Gain(gain in 0..1)`
    - makes fuctions in syntax more complicated than needed. `dsp gain` is direct minimum.
    ~ maybe we better keep dsp keyword as indicator of not simple function

  7. Create instances as `[process, reset] = gain(...channels)`
    + provides config
      - not convinced it's needed
    + config can potentially take number of channels and type of params `[process, config] = gain(2, 1)`
      ~ `sampleRate` can indeed be global
    + allows pre-select clause to use for mass-processing, depending on number of channels and type of param.
      ~- doesn't let dynamic switch of channels, need to have multiple instances for simple action
    + less problem with fn args number detection
      ~- isnan is not a big deal
      - number of args can indicate k-params more precisely
    - grows memory, ostensibly slow but irrevokably
      ~+ can rotate instances by calling `reset`
      ~- reset can also be implemented as module-wise method and module can be reused too.
      ~ still need memory delegation per function for allocating state
    + makes use of `alloc`
    - complicates JS API by initiation step
      + doesn't need to export alloc for JS API, if that also creates refs to memory locations
    ~~hides current value of global time, global index~~ ‚Üí no need for global state
    + could allocate memory / callsite id at the same time.
    + even simple functions may have state = therefore we need to instantiate callsites.
    - instances cannot reuse same memory
      ~+ instance fn can still take all created pointers (or any other pointers)
        - clauses if reuse memory cause shallow alloc
    - makes direct functions impossible, as well as functions with kParams
      ~ can be alleviated by `[fun] = fun()`
      ~+ if instance fn takes pointers, can take kParams then
  7.1 instead of instance constructor, we can call fn directly, and that creates instance the first call
    + allows direct fn calls
    - tricky js API

  8. `@batch()` decorator
    + decorator is right meaning
    + able to initialize batching params (channels? rate?)
      -~ doesn't seem we have params to pass
    - extra concept

  9. Hooks-like callsite-identifined state.
    - we're going to need to identify not by the last callsite, but by the full stack.
      * imagine a‚Üícoin()‚Üíadsr(), b‚Üícoin()‚Üíadsr(). adsr is called from the same callsite, but by different external method.
      ‚Üí all exported fns must obtain instance id somehow (mem offset?) and pass it through;
      ‚Üí all internal fns must pass parent callsite id + internal callsite id to internal calls;
      ‚Üí since we don't provide instancing mechanism, JS instancing is done either via stack/ctx id (mem offset), or regular wasm instancing.
        ? Can we maybe expose methods allocating memory for all fn reqs? There's too plenty of them: `args per channels, output, context/callsite`
          * context also may require special amount of memory, it's not clear how to allocate it from user side
          ~ that is similar to instancing from 7.
          ~ fn can reserve memory for itself, context/callsite args may not be necessary
            * eg. on instancing of WASM module
    ‚Üí we could provide global `instance` variable, switching current context, but that duplicates native switching.
      ‚Üí better export global `reset` to enable instance rotation.
      ‚Üí generally functions allocate own memory on first call, with assigned unique callsites within current instance.

## [x] Batch function reads from memory; regular function takes arguments. How to differentiate them? ‚Üí we don't have batch functions, loops are trivial

  1. `export` === processing
    - `import pow from 'math'` is not processing function
      ~ it's not necessarily external, if imported by wasm.
        ‚Üí Sonr can resolve imports to become internal.
    - makes simple things slower than needed (reading from/to memory)
      ~ not true for internals
    - disallows direct params
      ~ not sure if exports need direct params

  2. Indicate parameter type: `gain(x:aRate in -1..1, gain:kRate in 0..1)`
    + better distinguishes clauses
    + allows direct params as `gain(x:aRate in -1..1, gain in 0..1)`
    + allows implicit input type as eg. `gain(x:input in -1..1, gain)`
    - doesn't propagate type info down the source
    - colon can be used for loops, x:action means do action until x is true

  3. Imply param type from name `gain(ax in -1..1, aGain in 0..1)`
    + csound-like
    * ? mb worth taking csound conventions:
      a=audio rate calculation‚Äîcalculated once per sample
      k=control rate calculation‚Äîcalculated once per control period
      i=init rate calculation‚Äîcalculated once at the start of the instrument
      g=global
    + reminds in source code about nature of variable, without implicit type
      ? is that helpful anyhow?
    + g can be used for `gTime`, `gSampleRate`, `gBlockSize`
      + OpenGL uses `gl`, `glu`, `glut`, `glew` prefixes https://www3.ntu.edu.sg/home/ehchua/programming/opengl/HowTo_OpenGL_C.html
      ~ can be competed with `#t`, `#sampleRate`, `#blockSize`, `#input`: `gain(#x, aGain in 0..1)` can mean implicitly passed #x.
        + a |> b(1), b=(#a,b)->#a+b
        ~ # is also a sort of prefix
      - nah, prefixes are too limiting & that's anachronism
    - can be problematic destructuring: `gain((al,ar) in -1..1)`

  4. Imply batch from channel inputs gain((..ch))?
  5. Indicate batch by `~` symbol.

## [x] Batching

  * Batch runs a fn against some context like `#t, #i, #sampleRate, #blockSize`, incrementing #t/#i
  * Batch must compile fn clause, not take some fn
    ‚Üí we don't batch compiled clause/function by external means, batch is special defined-in-advance clause with loop inside
  * batch can take last argument as number of items to process (count)
    - that implies for multichannel input to pass pointers to each individual channel, or else that count gets meaning of "blockSize" (not generic number of samples to process)
  ‚Üí just have global blockSize, allocBlock and make functions match signature in son 1:1, by passing blocks for batching

## [x] Latr: alloc, array etc.
  * latr can provide alloc and other common helpers
  - not latr but std. Latr is generic synthesis/science
  * Lino Audio Testing Routines
  * Lino Audio Toolkit ... R?
  * Laboratory Transformator

## [x] Arrays: length ‚Üí `arr[]` for length is the most natural
  * Ref https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)
  * Ref https://en.wikipedia.org/wiki/Cardinality
  * Lua, J langs propose # operator for length
    + Math #S indicates cardinality. (number of something)
    + `#` is `number of` (in Russian ‚Ññ)
    - `#str` in module space means "load module", `#str` in function scope means `length of function`
    - `#str` doesn't work well as "length of string"
    -~ `abs()` allows group inside, making # a unary operator would create `#(a,b,c)` stuff, which has strong intuition as records-ish
      - `#(a,b,c)` doesn't make clear if that's number of items or abs values of all internals (likely the second?)
    - `#` borrows from `a4#`, which would be nice ids for notes.
  * `\` for length:
    + Similar to ·¥ì === radius/diameter of something
    + Escapes === "literal" meaning of variable
    + Less noisy compared to #
    + Leaves # available for identifier names & notes
    - looks yucky, like escapes/regexps
    - TeX guys and score notations like Guido use `\` for command
  * Icon, Unicon propose * operator for length
  * ? `melody_string[]`
    ~+ sort of math association
    ~+ sort of #, but not as generic
    ~+ empty array is unused anyways
    - `(a,b,c)[]` is a mess, `#(a,b,c)` is fine.
      ~ not really an argument.
    + natural-ish, puts in the same row as members access
    + points to modulo operator, like, accessing not single member but length
  * ? We can do |a| operator for abs(a) or a.length
    + Math notation is |a|
    - fn syntax is waaay more familiar
    - higher entropy compared to other ops
    - symmetricity causes special parsing requirements as prefix/postfix: `|a + |b * c| / d|`
    + rust uses that for closure syntax
    ~ not a big deal tbh, arr[-1] is good for last el
  * ? We can do a[0] for array length, and start items from 1: a[1], ...
    + last element coincides with length, a[a.0] === last
  * ? we still may want to have .last, .length aliases
    - .length can shadow named array properties.
      ~ not a big deal: that's just an alias
    - .length isn't nice for groups
      ~ that's fine too
    + we use aliases in fn arguments, in arrays anyways
    + that's strongest convention
    - that violates no-keywords principle somewhat, forcing generic structures into latin range
  * channels | len
    - precedence isn't nice

## [x] Bitwise operators ‚Üí let's stick to common syntax and not break it

  1. JS convention: a|b, a&b, a^b
    - occupies significant operators with secondary operations
    - conflicts with a^b as math exponentiation
    - conflicts with topic operator ^ + b
  2. Overloaded a+b, a*b for booleans
    - doesn't apply for integers
  3. Reverse convention: a&&b, a||b, a^^b for bitwise
    + shorter conditioning a & b | c
    - unconventional
  4. Get rid of them
    + they occupy very useful syntax space
    + it's not very clear which numbers we're dealing with: float or int?
    + bytebeat is very narrow subset of sounds and is unlikely to reproduce anything super useful
    - makes bytebeats harder to implement
    - makes useless 0x00 and 0b00 notations
    + less questions of converting one numbers to another
  5. `a/\b, a\/b, a><b`

## [x] ASI (semicolons): semicolons or not? ‚Üí enforce semicolons. But last one is optional.

  1. Don't enforce `;` everywhere. Recognize newline intelligently.
    - C/Java-family has them mandatory; Also many JS folk tend to make it mandatory also.
    - It's just simpler and more explicit to have them everywhere
    - It's also a bit low-level-y feeling, which is rather good
    - easier to parse via ;
      ~ prohibits empty statements
    - no ASI JS problems
    - there's no that blankline intuition in natural languages nor math:
      newline continues prev line, explicit convention
    + "bullshit" noise
      ~ well it's line noise

## [x] Make channeled input an array: `gain([left, right], amp)` instead of group destructuring `gain((left, right), amp)`? -> nah, avoid unnecessary meaning for destruction

  + array better refers to memory send to input, not some internal grouping - so it's a "frame"
  + it allows more clearly indicate output signal, opposed to just grouped value:
   * `phase -> (sin(phase))` === `phase -> sin(phase)` - because group of 1 element is that element;
   * `phase -> [sin(phase)]` - that's output signal.
  - returning [..ch] vs [..size] ‚àí conflict with array creation
    - [a] means frame with 1 channel, [a] also means array with 1 item.
    - [..a] means frame with `a` channels, [..a] also means array with `a` items.
    ? prohibit array signature in favor of groups: `(..size)` can define a group as well...
      - nah, groups are just syntax sugar, they don't have serialization or own taste, whereas arrays do.
    ~ if blockSize === 1, block frame becomes identical to array
    - when we return [a,b,c] it implies frame, but we may want regular non-batch array result, do we?
      ~ worst case it creates redundant block, but the way value is read from it is still array-like frame.
      ‚Üí ok, let's keep same for now: it seems array===frame is not a crime
        -? how do we adjust block-size then? We don't need 1024 items spawned instead of just 1.
        - frame output creates internal unnecessary loop
  - also, `fn([..ch])` is not nice notation for just getting all channels. Marking argument as "input" would be easier.
  -> Nah, avoid unnecessary meaning for destruction.

## [x] No-keywords? Let's try. i18n is a good call.

  * for(a,b,c) is valid fn; if(a,b) is valid fn;
  + It allows compressing code to no-spaces, which can be nice for serialization to/from string;
  + Natural languages or math equations don't have keywords in punctuation. Imagine if we had to write sentences where some of words were syntactic. It's fine - everyone got used to punctuational conventions and even don't mix up ...a and a..b
  + From ancient times scientists separated meta-meaning (take music staff notation) from actual content by different kind of notation.
  + No-keywords removes English language bias, allowing real i18 code.
  + It frees user from caring about variable name conflict. `in`, `from`, `if`, `for`, `at` can be useful variable bits.
  + JS keywords are ridiculous: they block many good names pushing user use marginal names.
  + keywords play role of comments anyways. It's better to put freeword explanation into comments rather than pollute language.

## [x] Compiler: Wasmtree instead of IR would be simpler -> nope, it's less flexible and less supported

  * ['module', ['func', '$name', ['param', 'a', 'b'], ...statements], ['global'], ['exports']]
  + it would allow to just apply a bunch of transforms to inputs, keeping the format
  + it takes less space and less computation
  + it is easier serializable

## [x] Do we need arrow functions? ‚Üí Lets wait for use-case for now, but worst case make them macro/operator-helpers

  ? Are they unnecessary?

  - two types of fn declaration - direct and "situational"
  - we have just single use-case for now, which seems to be "fancy js" rather than sound code
  - classic sounds indeed don't use situational functions, maybe that's even against nature of sound mechanics
  - in line noise paradigm <-, -< / ->, >- they create a bit of abstract level confusion:
    * <-, -< act on "flat" level, whereas
    * ->, >- () -> act on "functional" level
  - introduce questions how to use pipes a | x -> x+1: without arrow fns there would be less options
  -! reduce/flat can be organized as `i < #arr <| sum += arr[i++]`
  -! map can be organized as `(item <- arr <| item * 2)`
  -- (+) it frees `->` operator space, making it asymmetrical
    + can be filled! like map?
  -- (+) `|>` still kind-of requires function on the right-side and is similar to `|` operator
    !+? can take attributes as `(cur, next) <- arr -< a + b`
      - nah, likely need to be `(cur, i) <- arr`
    ?! what if unlike `-<`, `>-` "reduces" attributes as `(sum, item) <- arr >- sum + item`
    ?! what if use `->, >-` pair for map/fold/converge? like `arr >- (a,b,c) -> a + b + c`
      + looks similar to old patterns
      + has nothing to do with arrow functions
      + arrow functions are macro-helpers, not runtime constructs

## [ ] Live env requirements

  1) compilable in a worker thread
  2) hot swapping code in the worklet as it is playing and reusing memory state from the previous compile. If there's a delay/note/reverb tail playing from the previous compilation, and i compile a change, the new instance should inherit all the memory/buffers from the previous one, not start from zero. I have to be able to make changes without affecting the sound that is playing (too much). It won't be possible for 100% of the cases, but if the compiler can match the previous buffers with the new one then it should reuse them.
  3) parser/compiler errors with line/col/symbol/token information so they can be displayed inline in the editor while the user is typing, so they see what they're doing wrong. They don't need to be extremely descriptive, but at least showing the right symbol position i.e what to draw red.
  4) a way to export certain parameters into UI elements arbitrarily and with minimal effort. Right now in mono i've introduced a . prefix operator in the arguments so f(a, b, c) if i do f(a, .b, c) then i immediately get a knob for 'b' with that simple addition of the . prefix. That helps me a lot as a producer to not have to go elsewhere to define these and to try new things. The '.b' also becomes hoverable and can change with the wheel, but there's also a UI knob and they're associated, when you hover one, both light up. The idea is that once you export the controls like that, you can hide the editor and that can be a standalone effect/instrument with those controls it pulls from the code. You want another thing to tweak? Simply jump into the code and add a . next to the parameter and save. When there will be dozens of instruments and effects in the screen playing you need to be able to quickly do these things so you don't kill the flow. The flow must never be killed. That's the most important feature. You should be dancing all your way through from start to end while making a track without any gap of having to stop and take closer look at code or something isn't playing right or there are audible glitches etc. So first and foremost it is a party tool. You need to be able to party with it or it's worth nothing.

## [x] Tape machines -> try using array with shift, no need for explicit tape machines

  * They're like buffers/arrays, but every batch call they shift index.
  * In a way similar to static variables, but in fact state arrays (variables with memory of prev values)
  * In mono done as `v()=(#:1; y=#(0); #=y+1;y);` (create, read, write)

  1. `v = (in[2,1024]) -> (*state[1]; y=state.0; state.0=y+1; arr[100]=[1,2,3]; y)`
    + familiar conventions: init as type, stateful, access as array.
  ? have dim extension to any variable?
    - confusable for array
  ```
  fn = () -> (
    *a[1s * 48]; \ init stateful variable with 1s of memory
    *a[1s * 48] |= i -> abs(i); create stateful variable with past values
    a.0 = 2; \ write 2 at index 0
    a[0] = 2; \ same

    a.0 \ read current value
    a[0] \ same
    a.-1 \ read prev value
    a[-1000] \ read 1000th prev value (no rotation)
    a[-10..0] \ get array of last 10 values

    array = [..a] \ create array from all prev values
  )
  ```
  - init is conflicting with array property access.
    - we may need to expand that notation to defining arrays for any variables, eg. `a = [0..10]` vs `a[10]`,
      but obviously the latter is just array access.
    ~ that's special modifier for stateful initializer.
  - there's never positive index btw
    ? flipping to positive?
      - reversed logic for sound
  - 3 variations of structures/access: array, input, memory.
  ? what if we make regular arrays init as `a[3] = [a,b,c]`
    - confusing with setting 3rd member
  ? maybe that's fine not to have arrays defined like that?

  1.1 Init all variables via `~i, ~x, ~s` etc.
    + brings arrays to the same level as `~arr[10]`, `*state[10]`, `(in[2,1024])`
    + literally means "variable"
    + indicates all used variables explicitly
      - forces redundant notation: can easily init directly
    + introduces "variable type": can be `.param=10 <- 0..100` for external param via UI (unlike argument).

  1.2 ~~Alternative notation for saved state: `v = (in) -> (*a[10]; a'0=a'-1+a'-2)`~~
    - Mess up with strings/quotes, nah

  2. ~~`v = (in:(3,1024) <- -1..1, amp) -> (*a:(1s*48); b:1024 = [1,2,3]; a.0 + b.0)`~~
  - same drawbacks
  - less apparent
  + non-conflicting notation
  + reminiscent of types
  + colon is free-ish
  - args messup via comma
  - not elegant parens

  2.1 ~~`v = (in:3:1024 <- -1..1, amp) -> (*a:1s*48; b:ch:1024 = [ch1,ch2]; a.0 + b.0)`~~
    - doesn't match neither with `[]` nor `.`
    - confusable with naming/alias - `[x:10, y:20]` - is that array with aliases, or array with 2 arrays?
  2.2 ~~`v = (in#3#1024 <- -1..1, amp) -> (*a#1s*48; b#ch#1024 = [ch1,ch2]; a.0 + b.0)`~~
    + reminds length by meaning
    - crammed noise
  2.3 ~~`v = (in.3.1024 <- -1..1, amp) -> (*a.1s*48; b.ch.1024 = [ch1,ch2]; a.0 + b.0)`~~
    - same drawbacks as `[]`

  3. ~~`v = (in{3,1024} <- -1..1, amp) -> (*a{1s*48}; b{1024} = [1,2,3,...]; a.0+b.0)`~~
  - bad association with heavy stuff: sets, objects, structs, block etc.

  4. Don't use any special notation for arrays.
    + we know array sizing in advance on init, always-ish?
    ~ we can allow a[] = [1,2,3] for autoinit
    + mem state and input arg state are indeed a bit special cases
    + `*x[100]` or `(in[100])` can be more thought as "index space" rather than special object kind definition.

  5. Can't we just define infinite memory / past values?
    * mem layout seems to be helpful & useful elsewhere
      ? like where? we don't really use it: arrays can be figured out from memory itself...

  6. Don't use any arrays syntax extension: `v = (in <- -1..1, amp) -> (*a = [..1s]; b = [1,2,3,...]; a.0+b.0)`
    + Solves problem of syntax.
    - Doesn't solve problem of tapes / inputs:

  7. Use unindexed `v = (in[] <- -1..1, amp) -> (*a[] = [..1s]; b[] = [1,2,3,...]; a.0+b.0)`
    + Unified notation
    - Not really useful if we assign arrays after anyways
    + We may not ever need initializing arrays to some length, like `b[100]=[1,2,3];`
      * It can always get length from values.
        - we may want to have sub-array though instead of slicing original array, ie. `b = a[0..10]` and `b[10] = a` are different.
        ? do we ever need slicing arrays? Can't we just always return subarrays?
        ? to actually slice array we'd need create new one as `b = [a[0..10]]`
          + more explicit reflection of what's going on
          - we can't easily subarray as `a[1,3,5..7,-1]`
      * Whereas input arg makes sense as both `in[]` (iterate all available) and `in[100]` (iterate until 100).
      * Same as memory `x[]` - save all values ever and `x[1s]` - store 1s of data.

  8. Indicate dims in advance? `v = ([2,1024]in <- -1..1, amp) -> (*[1s]a; [1024]b = [1,2,3,...]; a.0+b.0)`
    + matches prefix type indicator pattern
    - swaps order: `[10]in; in.7=1` vs `in[10]; in[7]=1`.

  9. Make first (init), then read. `in[10] = [1,2,3]; in[9] = 1;`
    - very confusing same notation different meaning;
  9.1 `in[10] = list` means create sublist; `in[9] = number;` means write number;
    + There's a chance we cannot export array with various-type values from WASM, like array must be unitype and not nested.

  10. Length operator: `v = (in\1024 <- -1..1, amp) -> (*a\1s; b\5 = [1,2,3,...]; a.0+b.0)`
    + matches length notation
  10.1 Old length operator: `v = (in#1024 <- -1..1, amp) -> (*a#(1s*sr); b#5 = [1,2,3,...]; a.0+b.0)`
    + matches length as `#in === 1024`
    + matches meaning of # as length
    + reminds # from mono
    ? how to define unknown-length?
      ? maybe enforce length and enforce passing memory pointer?
    - looks noisy, # wants to be part of id, not full operator
    - calculated values like `a#(1s*sr)` require more characters
    - not clear how to indicate any-length
    - occupies # char

  10 + 8. Alt length operator `v = ([]in <- -1..1, amp) -> (*[1s]a; []b = [1,2,3,...]; a.0+b.0)`
    + both kinds of sizes possible
    - lame as length/abs operator: []123 is lame.
    + `*[]x` has more meaning than `*x[]` - this way we indicate size of memory, not size of `x` in memory.
    + `[]x` is golang array notation

### [x] Should we instead of batch variable indicate arg layout? -> ~~yes, meaningful for all input var, array var and state var.~~ no, just array pointer

  Before:
  ```
  gain(~in, amp) = ~in*amp;     // input/output channeled data (for batch call)
  generate() = (
    ~chans=[left,right,..rest]; // define channels (batch) variable
    chans.l, chans.r            // channel name aliases
    chans.0, chans.1            // channel index aliases
    chans
  );
  ```

  After:
  ```
  blockSize
  gain = (in[2,blockSize], amp) -> [ch <- in <| [x <- ch <| x * amp]];
  generate = () -> (chans[2,blockSize]; chans);
  ```

  + allows customizing block size / channels layout more explicitly
    + no implicit layout conventions = less configurations
  + matches memory var signature
  + output is just an array
  + compatible with array, just different processing meaning, so `arr = [..tape]` can be just copy
  - [x] it doesn't iterate over values automatically and needs some extra wrapper
    + allows more explicit iteration pattern
    + allows direct mono/stereo clause as `gain0 = (in, amp) -> in*amp; gain1 = (in[1024], amp) -> x <- in <| gain0(x, in)`
    + in fact, arrays can expose ops automatically to all elements, so that `gain(in[len], amp) -> in * amp` just multiplies all.
  - no channel name auto-aliases
    ~? can be made global swizzle aliases?
      + can be overridden by named indexes
    ~? can be provided explicitly as named indexes
  - no clear intuition does that behave like array or saved-state array?
  + very natural notation, as if groups are created for expressing strides
  !+ arrays can be always flat, but layout defines how they should be read

### [x] Tape machine: layout/access logic? -> ~~let's do a.0, a.1 for past values~~ let's not do past logic due to access tax

  1. a[0] current, a[-1] prev
    + very natural
    - long syntax
    + better mem implementation: compiles to a[(iteration+shift) % len]
  2. a[0] current, a[1] prev
    + allows a.0, a.1, a.2
    + better memory layout (in order)
    + matches array layout
    + it already indexes like that in biquad filter code `x1,x2 = x0,x1`

## [x] Variables: how do we make var/let/const? -> implicitly; globals are available for read, but not write on the first line.

  * The logic: we use global fns directly, so globals should be available without prefixes either: `f()=sin();`
    * we don't redeclare something already available, and we declare something new: `f(a,b,c)=(*d,*e;)`
      + this allows preventing typos as well
      * same time global we define as `a=1`, therefore local must be as simple, `a=1`.
        * yes, and we can import global fn also (with new scope) as `f() = (^g; g())`

  * `~x,~y=2;`
    + `~` means "variable"
      - conflicts with `~` for clamp
    + introduces "variable type": can be `.param=10 <- 0..100` for external param via UI (unlike argument).
      + state variable `*`, ui variabl `.`, regular variable `~`, const `-`
    - conflicts with global "no-prefix" inits `a=1;f()=(~a=2;)`.
      ~ we can make it an indicator of actual variable, opposed to const `-arr[10]`
        - still, pollutes global...
          ~ can be quite useful, as indicator that we don't change globals. So only globals can be defined directly.
    - a concept user doesn't have to know necessarily
    + is not new syntax, just an extra meaning for regular syntax - doesn't break anything

  * `+x,+y=2,-z=1; +(a,b,c);`
    + same as previous but less heavy
    + `+` means arguments AND locals

  * `:x,y,z;`
    + nice use of `:`
    - not standard syntax

  * `x(a,b;c,d) = (...)` for local variables
    + no new syntax
    - unusual use

  * `x(...) = (&(a,b,c); )`
    + args AND locals

  * `x(...) = (@(a,b,c); )`

  * `x(a,b,c=c,d=d)` - list globals
    - no clarity about reassigning global
    - no way to set it

  * `x(...) = (a,b,c;)` - effectless group/vars make them init
    + organic, intuitive
    + it's not good to use unknown variable right in the middle of the code: prevents typos
    - is it init or global assign `a=1, b=2, c=3;` (see below)

  * make naming difference of locals/globals
    + maintains scope transparency
    a. `x(...) = (_a, _b)` - lowdash to enforce local
      + global never starts with lowdash
      - forces all internal vars be prefixed
    b. `x(...) = (a + A)` - capcase for global
      - enforces cap-sensitivity
      + like Golang
    c. `$a=1;x()=(a+$a)` - prefixing like Ruby
      - limited naming scope: fns dont have to be named like that
      + displays global explicitly

  * indicate globals anyhow, like `global x`
    + `window.x` is good JS practice, vs unclear `x`
    + python, PHP has that practice
    + we don't need to initialize global variables
    ? how

  * force globals to be constants/modifyable from outside only
    ~ globals can change, eg. subscript
      + can be done via static variables
    + can be worked around as array `cur = [0]; x() = (cur[0]; cur[0] = 1)`
    - throws compile-time error, but the problem remains: we may not have control over 3rd party code to isolate locals
      ~+ any write to global will create local variable instance
    - artificially limits globals

  * global var is same as static by meaning
    + `g=1;f()=(*x=g;)` is same as `f()=(^g;)`
    + like Python - we can make writing variable as local, and reading as transparent
      + that seems to be a pattern: we read imports but write from outside; we read globals but write from outside

  * first line is for declaring locals, rest is read/write globals but define locals `a,b;f()=(a=1;b=2)` - defines local `a`, writes global `b`
    + compatible with last-line for returns
    + intuitive as sequence of vars `a,b,c;` for declaring locals (prev option), but assignment is allowed on first line.
    + matces `for (init; before; after)` syntax

### [x] Variables: how to indicate global vars? -> ~~`^x;x;`~~ globals are for read by default and for write after first line

  1. Python `global x;` + prevent modification
  2. Ruby `$x;`
  3. `f(a) = (^x; x+a);`
    + reference to "global" scope
    + nice use of `^` operator
    + python compatible
    -~ new operator, not full reuse of existing one, no precedents of such use
    * should be used once, on on declaration, eg. `x() = (^size; size=123)`, since must be same as global fn use ``
    + we need it to simplify internal implementation also
  4. `f(a) = (<x>; x+a);` as declaration
    + indicates place of "insertion" like imports
      + kind-of in-sync with logic, since globals can be imported in global scope same way
    - interfere with imports
    - not as compact as `^`
  5. See prev question last answer

## [x] Variables: UI variables -> move to latr

  1. Special syntax?
  ```
  gain(in) = (
    .amp = 1 ~ 0.1..100;       // create UI knob for amp
    in*amp
  );
  ```

  2. Can be just external fn
  ```
  'latr#knob'
  gain(in) = (
    amp=knob(1, 0.1..100);       // create UI knob for amp
    in*amp
  );
  ```
  + better customizable: log axis, linear, type, step
  + comes with other tools: logging, profiling

## [x] Remove loops? -> let's try removing `<-` as `in` operator

  * We can replace `x <- list <| x + 5` with `list | x -> x + 5`
  * We can replace `x < len <| body` with `..len | i -> body`
  * We can replace `condition <| xxx` with `0.. | i -> xxx`
    ?~ break can be done as `0.. | i -> (!cond ? ^^; xxx)`
  + makes `<-` actual clamp operator, rather than `in`
  + keeps only standard connections

  * ALT: we can remove only `<-` from iteration, replacing it with `set | x -> x`
  + removes ambiguity of `<-`: for clamp only
  + simplifies cases
  + removes left-direction case like `x <- list <| xxx`
  + makes loops less frequent and more meaningful
  + `<-` as clamp replaces min, max as well

## [x] Channel aliases / ordering note -> can be defined manually or via musi

  from https://learn.microsoft.com/en-us/previous-versions/windows/hardware/design/dn653308(v=vs.85):
  Front Left - FL
  Front Right - FR
  Front Center - FC
  Low Frequency - LF
  Back Left - BL
  Back Right - BR
  Front Left of Center - FLC
  Front Right of Center - FRC
  Back Center - BC
  Side Left - SL
  Side Right - SR
  Top Center - TC
  Top Front Left - TFL
  Top Front Center - TFC
  Top Front Right - TFR
  Top Back Left - TBL
  Top Back Center - TBC
  Top Back Right - TBR

## [ ] Try-catch: -> `x() ?= (a, b, c)` makes fn definition wrapped with try-catch

  ! Golang-like `result, err = fn()`
    + matches reverse-ternary op
    + also see trytm https://github.com/bdsqqq/try
    + returning group is nice, since the convention is always as last-element=error
    - can be an overkill to wrap every function in try-catch
  ? what if we define `throws` for the time of fn definition as `x() ?= (a,b,c)`?
    + better matches `try-catch block`
  * A symbol can be one of `!`, `@`, `?`
    ? `result, err = ?fn()`
      - conflicts with `a ? b`, `a ?: b`, `a ? b : c`
        - like `a = ?a() ? ?b() ? c() : ?d() ?: e()` - holy...
    ? what if `res, err = fn?()`
      - `a = a?() ? b?() ? c() : d()`
        - if we introduce plain conditionals `a ? b`, `a ?: b` then `a?(arg)` is indistinguishable from `a ? (arg)`
    ? `res = fn() : err`
      - same as above: `res = a ? fn() : err : fn2() : err`
  * Possible syntax: `fn(a) ?= (!a ? 'Bad arg'!; 1/a);`
    - no: `a ?= b` is `a = a ? b`, same as `a ?:= b` is `a = a ?: b`

## [ ] Try-catch: How do we define throw?
  * `!'Error message'`
    + makes use of atoms
  * `?'Error'`
  * `^'Error'`
    + similar by meaning to return
    + returning an atom indicates error
  ~- we can do that via just returns
  - Errors make program syntax case-sensitive

## [ ] Variables: Case-insensitive? -> likely yes: AbB/ABb, x1/X1, ~~@math.E/@math.e~~, export names, import names, constants, strings, atoms
  * should not be too smart, should be very simple

  0. Case-insensitive

  + simple
  + it's safe: like html attributes, no gnastly name conflicts
  + https://twitter.com/bloomofthehours/status/1491797450595528713?s=20&t=1aJpwIDrbNhIjwIohsvxiw
  + reduces use of camelcase convention
  + lowcase constants are fun `4p * i`
    - can define via units
  - `AbB` vs `ABb` can be different chords, but piezo mixes them up together
    ~ can be addressed via separators `Ab_B`, `A_Bb` or (?) `Ab.B`, `A.Bb`
  - `X1` and `x1` can be different things in math
    ~ can be solved as eg. `x1` and `_x1`, `@x1`, `#x1`, `$x1`
  -~ `sampleRate` becomes `samplerate` - can be confusing
    ~ doesn't have to lowcase
  - export naming: `'AbB': AbB, 'sampleRate': sampleRate.`?
    + can take exact name though
    + lowcase-enforced export is kind of cool, `exports.samplerate`
  - not much conventional, only MySQL and other oldies
  - import question: `@math:E` vs `@math.e`
    ~ can be solved via manual imports
    ~ can be checked for undefined on compile stage
  + solves problem mentioned by despawnerer (`dateRange` vs `daterange`)
  + lowcase is typographycally more expressive
  + code is robust to changing case, eg. as url string
  - `1Ms` vs `1ms`
    ~ not sure it's good idea to designate such meaning to capitalization
    ~ `1Ms` is super-unlikely, for bytes can use `1mb` - it's never millibyte
  + `#@$_` alleviate case-insensitivity
  - Strings don't allow code to be case-change robust.
    * we either discard strings or make it (half) case-sensitive
  - Atoms may require case-sensitivity, eg. for error messages
  - user constants make no much sense `PI = 3.14`

  0.5 Capfirst-sensitive, (`Abc` == `ABc`) != (`aBC` == `abc`)

  - too smart
  + fixes problem of math/class capfirst difference (math `X1` vs `x1`, `Oscillator` vs `oscillator`)
  + fixes problem of despawnerer's `fullName` == `fullname`
  + capfirst is typographycally meaningful
  + fixes problem of units
  + more-less intuitive, good balance between 1 and 0, having mixed definitions `aBc` and `abc` is bad practice anyways
  - code is not robust to case-insensitive environments
    ~ we still support strings so we don't target these environments anymore
  - import looks like `@math#PI` still
  - doesn't solve constants issue, `PI` vs `pi` - would be cool to have `pi`

  1. Case-sensitive

  + simple
  + Enables extra room for naming, eg. `Oscillator` creates oscillator vs `oscillator` is instance
  + Doesn't create exports naming conflict: `foo_bar` is non-js export name, like `samplerate`
  + More conventional: JS, C, Python
  - Possible problem mentioned by despawnerer: `fullName` vs `fullname`.
  ~ MySQL is fine being case-insensitive
  - import becomes case-sensitive `@math#pi` vs `@math#PI`
  - upcase consts are ugly
    ~ can be replaced with units
  - less meaning to atoms

  2. Use atoms as case-sensitive variable names
  + enables quote-less imports `@math#pi` and `@'math#PI'`
    + `#` is part of variable name anyways
  - `'Oscillator'()` is unusual construct...
  - not clear if `'oscillator'`, `'Oscillator'`, `oscillator` and `Oscillator` resolve to the same
  - can cause conflicts with "bad" names, like `pipe/arg`

## [ ] Variables: id characters

  * `$`
    + yes
  * `_`
    + yes
  * `@`
  * `#`
    + allows notes a#
    + allows colors as variables `#abcdef`
    - reserves operator/syntax uses
    - non-standard

## [ ] Ranges: how to organize in wasm level? ->

  1. v128 as f64x2
    + stores
    - need to read vector item
    - exporting isn't allowed
    + exporting global is possible

  2. 2 spots in memory
    - need to manage memory
    - need to read from memory
    ~+ exportable as pointer?
    + easy from use-case point

  3. function returning 2 values
    + exportable
    + best fit for the use-case
    - extra call
    - can possibly be not the best fit for clamp/etc, will force creating temp variables or calling twice.

  4. immediate values
    - impossible to export
    + fastest & direct

  4.5 ranges as syntax sugar, not data type
    ? do we ever need saved/exported ranges?.
    + allows fast direct static ranges easily
    + removes tacky problems: ranges combination, min/max reading (since they're immediately available)

## [ ] Ranges: stack, heap, how? ->

  0. `a,b` saved to stack, `a..b` saved to heap?
    + meets limitation of 1000 members for stack
    + can possibly optimize sequences calc
    + allows returning plain arrays in JS side
  0.5. `a,b` saved to stack (static), `a..b` to array
    - entails GC
  1. `0..10` as v128
    - we can's store generic ranges `a..b[]`
      - we can, by converting to value immediately, which screws subsequent range step
    - we cannot modify ranges like `1..5 * 2 + 1`
    - a..b * 2 must be same length range
    - cannot export such function since v128 is prohibited for exports
  2. func ref or i64 referring to element table
    + static function can act as generator
    + can store all range modifications
    * `range1..a*b+c(a,b,c) = (*cur=1; out = cur * b + c; cur++; cur >= a ? cur=1; out);`
    * `range1();range1();...`
    - returning such function with dynamic params would require currying / binding mechanics
      * `x(a)=(0..a); x(10);`

## [x] Drop ints and use only f64? -> let's try to use only f64 for variables, but operands cast to types

  + waay less code
  + no type conversion question, since values are floats always
  + no type detection issue
  + f64 stores more ints than i32 (up to i52)
  - no compatibility with bytebeat
  - no meaningful shift/binary operations
    ? can we perform binary ops in terms of int parts of floats?
      ~+ i32 can be result of operation, eg. `a|b`
        * then we can track it similar to `static` property
        * eg. `(a|b)^c` doesn't convert back-forth between f64-i32 and only does binaries
      + we anyways track number of args from operation, so we can track their types or have flag detector in getDesc
  + less cognitive load for users:
    + less to learn from readme
    + less care about types
  + solves problem of variable reassignment, eg. `x=1;x=1.0`: we have only one type and don't wreck our brain.
  + we reserve i32 for internal tasks only
  + makes easy to store variables in memory
  -> ok, so variables are always f64, but calc results can be any, so we only extend i32 to f64 in assignment or fn return

## [x] How to pass int to a function? -> we force ints into floats

  1. Detect i32 from default value `x(i=1)=(...)`
    - default value can be calculable, not primitive, eg. `x(a,b=a)=(...)`
    - floats downgrade to ints in external calls `x(5.4)`
    - we need to track fn signatures to perform calls
  2. Enforce float args, `x(i)=(...)`
    + f64 covers i32 range anyways, so even binary patterns can be preserved
    - some tax of converting i32 to float, that's it

## [x] Use f32 instead of f64 -> keep f64

  + it makes arrays have same stride for storing diffent types
    - not necessarily good, since there's no meaningful way to export such arrays and also we have to track member types
  + solves issue of endianness of float64 arrays - no way from to read via Float64Array, need to use DataView
    - fake issue, works fine
  + enough for majority sound purposes
    - not really, mistakes accumulate
  + more cross-platform compatible
  - not really

## [x] Variables: Should var scope be defined by parens `(x=1;(y=2;);y)` or by function? -> use per-function scope

  1. By parens: `y==undefined`

  + see "scope or not to scope"
  + universal scope definition, just referential to parent scope
  + allows cleaner namespace, no name contamination
  + allows easier namespaces
  - harder to implement
  + streamlines scopes mechanism
  + allows merging globalParse & localParse mechanism, we just have to properly detect variables.
  - `(a,b,c)=(1,2,3)` - this initializer logically creates `a,b,c` within first scope, which is false.
  - in-scope variables are one-time use - they can relatively safely be reused after, can't they?
  - `try {let x = 0;} catch(){ x===undefined }` - is not nice JS footgun, often we need variable from internal scope
  - hard to explain to users what's going on

  2. By function: `y==2`
  + closer to webassembly
  + easier to handle variables since have access to them
  + more transparency, `((a=1;); a++; (a=2;))` feels fine
  + function scope is already defined by function,
  + keeps parens original "safe" meaning of precedence, no logic changes
  + simpler var naming implementation logic
  + less variables-per-function in result
  + solves issue of loops `a <| x -> (y=x)` - `y` becomes function-wise variable
  - no scope isolation like `let` in JS
  - global variable can affect workable local code: not nice

## [x] Variables: Overdeclaring local variables -> shadowing is not nice, we keep fn scope

  * `(x=1; (x=2;))` - `x` in both scopes is the same variable, so that we can't declare `x` within nested scope this way.
    - ie outer scope affects code within inner scope
  * that means there's one global namespace
  ~+ shadowing variables in JS is not nice practice anyways `let x = 0; if () { let x = 1; } `
    - but at least it secures/incapsulates code block, makes independent of globals

## [x] Arrays: Dynamic arrays, eg. `a->[1,a,2]` -> wait for structs generally, currently try memory pointers approach

  1. Alloc memory every return
  - needs somehow freeing memory, gc or manually
    - there doesn't seem to exist a reliable gc way, still would need manual run
  - harder for user to read values back: dealing with typed arrays, need to know $__memory naming

  2. Reuse memory by callsite
  - Subsequent call erases memory
  - Makes some conflict with stateful memory `*[10]a = [1,2,3]`, since that's almost identical by meaning except for auto-sliding

  3. Use multiple returns
  + Perfect user api
  + No memory collection issues
  - Limited to 1000 items
    ~ can be fine-ish for low-latency sounds
  - Compiles to bloated unrolled code
  + Limits lino to static (fixed-size) toy language
  - arrays make no point then

  4. Use wasm gc structs
  + standard way
  + perfect user api
  - not supported by anyone cept flagged chrome
    - chance it will ever be implemented is very small, since it super-complicates gc
    - gc: seems to undermine the point of wasm

  5. Prohibit dynamic arrays allocation: only global (exported) arrays
  + Maintains the old-school spirit of work with memory
  + That's good practice for DSP
  - That's inconsistent language API

  6. Prohibit arrays generally, in favor of work with memory
  + No need to add them until needed
  + Direct work with memory is more apparent
  ~ `x -> *[3]=(1,2,3)` returns internal fn memory, apparently
  +! we can redefine `<<` and `>>` for memory as shift operators, so that it's more apparent
    * `*[3]x; x << 1;` - shift left, `*[3]x; x >> 1;` - shift right
  ~? what's the difference between `([12]x) -> x` and `(*[12]x) -> x`
    * `*[123]x` allocates memory, whereas `[12]x` indicates reference to existing memory
      ? does that mean we can do `[123]x = memoryPtr`?
        ? whould we let creating at any offset then, eg `[123,6]x = memoryPtr`
  + that makes undefined-length arrays more attainable: `([]x)` means function can take any memory pointer
    * and we can track allocated memories, easiest way is to have length be `ptr-1`.
  ! we can define `|=` operator as `x |= x -> x*2` which transforms array in-place
    + `y = x | x -> x*2` maps x memory to y
  ? whad does `([]x) -> x | mult` return?
    ? temporary internal representation of mapped x items?
    ? or function itself becomes a macro, so that once applied somewhere else it just "unfolds"?
    -> the semantics is similar to loop, what does `i < 10 <| i * 2` mean? By itself it returns group, but if forwarded into `[]` it populates memory

  6.1 Make global `*[10]a` a memory reference.
  + Generally `*` points to memory
  + It's logically static - doesn't depend on callsite
  + Array here can be replaced with group, denoting init values

  6.2 What difference does it make creating array as `*[3]a = [1,2,3]` vs `[3]a = [1,2,3]` vs `*[1,2,3]`?

  * `*[]` can save into callstack, `[]` can just directly allocate.
  - direct allocation requires disposal which we want to avoid.
    ? wait for structs?

## [x] Arrays: 1-based index vs 0-based index -> stick to 0-based

  * 1-based
    * See ref https://www.reddit.com/r/ProgrammingLanguages/comments/t86ebp/thoughts_on_1based_indexing/
    - not very conventional
    + `a[1]` is first element (obvious)
    + `1..n` is common math notation
    + `a[-1]` is considered the last element conventionally, like 1st from the end.
      - same matches 0-based
    + `a[2]` as list creation corresponds to length of a
      - we don't create list like that - that's just accessing member
    + `-1..1` range more obviously indicates reverse operation, since `0` has no meaning as index otherwise than that
      ~ `0..-1` is kind of fine too
  * 0-based
    + very conventional
    * From https://www.jsoftware.com/papers/indexorigin.htm there's clearer arguments pro-0:
    + We're born at 0 age, time starts with 0 seconds, year 2000 is 1st year of 2-nd millenium, so index indicates the starting _position_ in a sequence, whereas 1-based index indicates number of an element.
      - but that's still first year, although it goes from 0 to 1
      . so it's a question either we choose offset as index or index as index
    + wraps `a[-1]` organically to last element
    - `x[1024]` creates an array of `1025` items
      + we create array as `[..1024]` or `[0..1024]` - which is 1024 members with exclusive lists, not as member reading

## [x] Allocate memory: `*[size]x = (1,2,3)` vs `[12]x = [1,2,3]` -> use arrays x = [1,2,3]

  1. `*[size]x = (1,2,3)`

  + allows to skip arrays for at least first time
  + enables `x << 2` operator for shifting memory value
    ~ although `x+1` can work ostensibly too
  - adds extra meaning to `*` from _stateful_ to _saved_.
  - there's no easy way to create in-place memory fragment: to pass memory, it needs `*[]x=(1,2,3,4)` which is weird
    ? can we create in-place memory fragment as `[1,2,3,4]`
      . but then we can't create `*[size]x = (1,2,3)` as easily, since just `*[12]x` doesn't allocate anything (it should).

  2. `[12]x = [1,2,3]`

  + more natural convention
  - no way to deallocate, unless we find something like `~x`.
  -> requires some GC mechanism

  3. `x = [1,2,3]`, `(x)->{}`, `*x = [..3s]` - don't introduce memory prefix

  + compatible with language logic: no separate notation for types, including array
  + memory block can be statically analyzed by most of the cases via usage/call semantics
    + eg. `a[1]`, `a.1` etc.
      ~+ we prohibit `i = (1,2,3)` then in favor of `i[0..3] = (1,2,3)`
  + similar to JS
  - external API requires defining array block via function or something, can't just pass region of memory
    ~ seems we're going to need dynamic allocation due to the following factors:
      * external API must define mem length somehow
      * length operator `a[]` should be meaningful dynamically
      * list comprehension, loop or fold can produce any-length lists
      * we're anyways exporting memory under some technical name
    ~ gotta need to implement `free` function as well or even an operator for that. `~x`?
      + reminds of markdown's ~~x~~.
      + that's syntax for C++ destructors
      + binary ops applied to arrays obtain new meaning -that's nice

  4. Via stdlib fully, `x = alloc(1,2,3)`,
    - no syntax support
    - no type checking
    - hard to write values

## [x] Pipe: should it work more as single-sample processing, or can take whole argument? -> ok, use pipe as iterator, benefits outweight block-processing functions

  1. `[1,2,3] | x -> x` - per sample
  + enriches mapper meaning with iterator
  + makes point as iterator operator in `<|`, `|`, `|>` group
  + expands meaning of `|` for ranges, lists, single values
  + makes memory ops waaay less prevalent and needed
  - inability to pass array to fn directly `gain([1,2,3],x)` - runs multiple times
    . we kind of prohibit passing arrays as fn arguments
      ~ on export we can wrap functions into optional params checks as well as passed-memory checks?
      ? also we can manually write exporter functions, targeted for our particular fx, eg. zzfx.lino
  + produces single-loop code which is good
    - doesn't expose function calls within that loop: fns are still called per-sample
      + Binaryen has inlining, potentially reducing fn calls into inlined code
  + it's just less cognitive load, keeps fn syntax natural

  2. `[1,2,3] | x -> x` - `x` is whole argument
  - makes only limited meaning as glue code
  - less meaning for `|` as iterator operator
  - produced code `arr | x -> a(x) | x -> b(x)` turns into a sequence of internal in-memory arrays and writing/reading ops to glue pipes.
    + that's faster within one processor, eg. `a(x)`
    + that allows single processor take arrays from external API `a([1,2,3])`
      ? can we work that around?
  - harder for optimizers

## [x] Functions: How to detect optional params -> comparing `a!=a` is not a biggie

  * If we enforce function arguments always be f64 we can detect it via NaN
    - unnecessarily slows down fn calls
    + allows external default args
    + with f64 vars there's no big problem for one extra check a!=a
  * Optional args must be detected statically in fn callsite for perfect performance
    - makes exported functions require all params

## [x] Arrays: rotate or not rotate? -> rotate via memcpy ops

  * Rotate: `list << 1`, `list >> 2`
    + Allows explicit ring buffers
    + Allows explicit memory buffers
    + If we implement memory buffers somehow else, we still need to store offset, not shift actual memory
    + Offset param is possibly fastest way to implement it
    + It makes use of i32 spot
    - It's slower on access, since it must apply extra memory read / sum operator
    - If we export such array, the memory becomes useless to read
      ? We may not need to care about exact rotation, array can have meaning as a chunk
    - There's no way to read the shifted amount by user
    ? Do we ever need rotating more than just 1 step?
    ? Do we ever need rotating right, rather than left?
    ? Do we ever need non-rotating memory in function body?
    - Rotate can be done as `a = a[1..,0]`
      ~ very costly
    - It can be implemented relatively safely by user, without perf penality and more explicitly
      . `a[offset + 1]; offset++`
      + since we already rotate index access via modwrap
      - prohibits static indexes like `x.0`, `x.1`

    ?! note: we can use `@i++, @p++` directives to indicate that phase is incremented after the fn call

  * Rotate as `a = [1..,0];` via memory copy ops
    ? how efficient is that?

## [x] Arrays: neg-index access or no? -> let's try modwrap + static optimization

  + handy & complacent with slicing
  - suboptimal performance, since enforces (idx % len) operation = reading array length
    - especially tacky to call included `wat/i32.modwrap` function
  - mod is not exactly right: out-of-limit write must not rotate to the beginning
    * the only meaningful range is -len..len, everything else must return null or NaN or alike
  + we kind-of need idx checker function if we're going to implement ring buffer
  + modwrap operator is for that purpose...

## [x] Functions: Scope resolution (fns within fns) -> functions have no nested functions and declared at the top level

  * Would be nice to make all variables local
    + less noise in code, + local.tee available
  * Same time functions need to have nested scopes, so common scope is global
    + allows storing tmp variables in local scope
  * Dynamic anonymous functions may need to have applied scope & access to global
    ~ Ideally we'd need dynamic vars creation, like `global $fnX/varX`
  * Alternatively, we can just inline any functions defined within functions
    - not always possible, like in recursion case, which is main use-case
      ~- maybe possible - via block or loop?

## [x] Functions: Make functions `f(x)=x` separate from mappers `f=x->x`? -> yes, let's separate

  + We don't support anonymous functions anyways `x -> y -> z`
    * with `x(a,b) = (a * b)` it's impossible to create anonymous function
  + We make it explicit that mapper is just syntactic sugar for iterator/fold, whereas function is runtime (exportable) construct
  + We solve compiler code inconsistency of passing `name` param to `->` expr.
  + `double(n) = n*2;` is shorter than `double = n -> n*2`
  + it's classic math notation for functions
  + it's compatible with mono
  + limits clamping more meaningfully
  + make more sense returning multiple values rather than mapper
  + mapper doesn't need to look fn-like `list | x,i -> i` (no need for scopes)
  + mapper visually belongs to synax better, than designating it with function meaning
  ?- some conflict/issue with storing functions in a table, eg `osc=[sin:x->x,tri:x->x]`
    * likely can be `osc=[sin(x)=...x,tri(x)=...x]`
  + resolves the issue of scope (above): no need to make all vars global since no scope recursion

## [x] Loops: What's the operator character? -> `a..b |> c`

  + Less problems with overloading `|`
  + Fold operator is likely not as useful
  + `|` and `|>` require fake function, which is whole mental concept
  + These things can be solved via single simple loop
  + One loop operator is way less cognitive load, than the plaiade of `<|`, `|`, `|>`, `->`

  ? how to do "in" operator, ie. `item <- list <> operator`? -> `list :: it * 2`
    ? `list -> item <> (item * 2)`
    ? `list -> item :: (item * 2)`
      - that operator `list -> item` has no meaning by itself
    ? `list :: x -> x*2`
      - confusion with function mappers, which it is not
      + c-like pattern `list::item -> item*2`, meaning for each item
      * loop as `a < 3 -> a++`
    ? `list -> item :: item * 2`
      + also c-like pattern
      + loop as `a < 3 :: a++`
      + list comprehension thing, reversed
    ? `item -< list :: (item * 2)`
      - wrong meaning to clamp operator
    ? `list ~ item :: (item * 2)`
    ? `item ~ list :: (item * 2)`
      - `lpf(x, freq, Q) = (x ~ xi,i :: x[i] = lpf(xi, freq, Q)).` looks unwieldy, compared to
        `lpf(x, freq, Q) = (x |= x -> lpf(x, freq, Q)).`
    ? `list ~> item :: (item * 2)`
    ? `list :item: (item * 2)`
      - `list : item : (item * 2)`
    ? `list :: (@ * 2)` - special character for item
    ? `list :: (& * 2)`
      + almost like pipe by meaning
    ? `list :: # * 2`
      + it's the shortest possible notation
      * `list :: ^^ # & #`
    ? `list#item :: item * 2`
      + very similar to `@path#item`
      - makes `#` an operator
      - `list # item :: item * 2` is not as obvious
    ? `item @ list :: item * 2`
      ?+ maybe combine with `pi,sin @ 'math'`

  ? what's the operator character? -> `::`
    * `<>`? `(while i<500 i++)` -> `(i < 500 <> i++)`
      + diamond is used in flowchart and condition
      - `<>` associates with not-equal from other languages
    * `::`? `(while i<500 i++)` -> `(i < 500 :: i++)`
      + ruby-like iteration
      + better for list comprehensions (classical-ish)
      + lightweight feeling
      - doesn't associate with producing/mapping, more just iteration
        +? maybe we don't need production meaning as much, since we rarely produce new arrays
          + list comprehension can be non-trivial to implement, since requires dynamic memory allocation and prone to memory overflow errors
      + allows `::=` operator, modifying list in-place, eg. `[1..100] ::= # * 2` or `[1..100] ::= & * 2`
      - it's not really pipe-able `out ::= gen() :: filter(#) :: amplify(#)`
        . with pipe that's `out = out |> gen() |> filter(#) |> amplify(#)`
          - doesn't look nice as self-assign `out |>= gen() |> filter(#) |> amp(#)`
    * `~>`? `(while i<500 i++)` -> `(i < 500 ~> i++)`
      + meaning iteration
      + associates with producing more

  ? how to implement in-place modifier, like `x |= x -> abc` -> `a ::= & * 2`

  ? ALT: `a < 10 |> i++`, `list | item -> item*2`, pipe as `list |= i -> i * 2 | i -> filter(i)`?
    + keeps the notion of "producing"
    + less mental load, `|>` and `| i ->` are similar
    + turns `a | b -> c` into a ternary (that's it)
      - somewhat parsing problem, it's problematic to have `|` of different precedence
    + keeps notion of diamond (flow loops) and vertical bar (pipe)
    + makes nice meaning to pipes `gen() | i -> filter(i) | i -> amp(i)`
    + makes meaning for `|=` as `out |= i -> i`
    + no topic operator problem
    + resolves `|` precedence problem
    ~- `|>` is confusable with pipe - it has little to do with pipe...
      ~+ it acts more as generator producing items (no need for intermediary `i`)
    - overwrite-generating `out = out |> sin(phase) | x -> adsr(x,a,d,s,r) |...` converts into
      `out |>= sin(phase) | x -> adsr()`, which is heavy operator `|>=`
      ~ would be easier to have `out ::= sin(phase)`?
      ~ likely relatively rare
    -~ overloading `|` (although resolvable, is not clean still)
    -? `list |> x` - how do we make difference with this and `a < 10 |> i++`? List is always truthy
      ? should we just make `|>` always for condition as the left part, ie. only `while` loop?
        + that would solve `|>=` operator problem
        - generators would become transforms `out |= _ -> sin()`
    ? should we make `a < 2 -> a++`
      - nah, non-argument meaning for `->` is not nice
    ~- blocks potential space for anonymous functions

  ? ALT: `list -> item :: item*2`, `a < 2 :: a++`, `list -> item ::= item*2 -> item :: filter(item)`
    + combines nicely list comprehension, for..in and while
    + known list comprehension pattern, avoids association with functors / lambdas
    + frees `|`
    ? modify list in place `list ::= item -> item * 2` doesn't make sense
      ?+ `list -> item ::= item * 2`
        ?- but then `list ::= gen()` skips member, generally member picking must be optional-ish operation
      + allows generating naturally as `list ::= a*b`, so that no `item` is needed
    ? pipes `list -> item :: filter(item) -> filteredItem :: gain(item)`
      + always returns a list
      - a bit lengthy and unpredictable
      ? should we prohibit pipes for explicity? `(list -> item :: filter(item)) -> item :: gain(item)`
    - a bit haskelly feeling, somewhat chunky, no pipes :(
    - `list -> item, i ::= item * 2` is not the most meaningful, unlike `list |= item, i -> item * 2`
      + pipes reinforce mention of anonymous functions that we try to avoid
    + `list -> item` and `a < b` are good left-hand part of a loop, indicating that the right part is repeatable
    + `:` has a bit more to do from branching in `?:`
    + No op overloading problems
    + No mention of fake anonymous functions
    + No conflict with `a | >b`
    + Leaves `|>` operator for something meaningful
    - a bit cryptic and non-intuitive things like `[0, .1, ...] -> x ??: lpf(x, 108, 5)`, `out ::= oscillator[shape](phase) -> x :: adsr(x, 0, 0, .06, .24) -> x :: curve(x, 1.82);`
    - reminds some crazy wasm spec `blocktype ::= 0x40       => [] -> []`

  ? ALT: `list | & * 2 | filter(&)`, `a < 2 | a++`, `list |= & * 2`
    + the most minimal syntax
    + classical look
    + member picking problem is resolved: it's optional
    - too short syntax for item iterators, it's more about pipe operator
      ~ see below
    - overloading `|` is not very wanted effect
    - having rhs as code is not very wanted effect, it "wants to be" in a function body
    - placeholder doesn't allow `idx` as second variable
    ? can we replace `|` with just a bit more elaborate, eg.
      * `a < 2 |: a++`, `list |: # * 2 |: filter(#)`, `list |:= # * 2`
      * `a < 2 |> a++`, `list |> # * 2 |> filter(#)`, `list |>= # * 2`
      * `a < 2 <| a++`, `list <| # * 2 <| filter(#)`, `list <|= # * 2`

  ? ALT: `list <| # * 2 <| filter(#)`, `a < 2 <| a++`, `list = list <| # * 2`
    + `<|` is graphically meaningful for loop
    + `#` is meaningful for member
      - reserves that keyword, can't simply use in var names, also smells from code perspective
        ~ kind of fine to redefine that for local scope
          - we don't redefine variables in scopes, we only assign values to them
            ~ kind of not the biggest evil
        ~ we can limit `#` to be used in var names as part, never by itself
      ? `.`, has almost same meaning & benefints
        * `list <| . * 2 <| filter(.)`, `a < 2 <| a++`, `list <|= . * 2`
        - will make export as last statement
          + which can be actually good & less noise & compatible with function return, it's unnecessary decorum there
        - conflicts with ranges as `list <| ...1` - is that `.. .1` or `. .. 1`?
    -? `for i, j` - how to refer to parent loop placeholder?
      ? `#`, `##`, `###`?
        + follows `^`, `^^`, `^^^` paren breaking logic
        + matches markdowns
        - `##` is messy and non-obvious
      ? `0..w <| (x=#, 0..h <| y=#)`
        + similar to fns
    + keeps spirit of pipes, more meaningfully
    + similar to JS pipeline proposal with all that's argumentation
    + **no mandatory member: allows while loop**
    + **no mapper fn-like syntax or syntax conflict with function**
    + **no global shadowing problem**
    + innovative & hereditary same time
    + **the most compact**
      + allows cool pipes as `sin() |> `
    - problem with mapping `list <|= # * 2` - too heavy for map operator
      + quite nice directional meaning btw, like arrow points that the result is rewritten by-element
      ? do directly as `list = list <| # * 2`
        - it's not obvious that we assign iterator result (group or last member) to initial variable
          ?+ why not obvious? quite obvious
      ? should we consider `list[..] = list <| #` instead?
        + keeps pipe untouched
        + introduce all-range operator (cool!)
        + matches lists reassignment
        + makes iterator meaningful in terms of returning result of pipe
        - not obvious that _last_ pipe member is written back, not _first_
      ? should we encourage `list <| ... <| list[i] = #` as result of pipe
      ? should we just make `#` writable as `list <| # = result`
        + very laconic
        + !clever
        + can modify list on the fly
        + allows short operators as `list <| # *= volume`
        - saving last value in pipe is weird `list <| #*2 <| filter(#) <| #=#`
        - we can iterate via range `0.. <| # = 1` - assignment doesn't make sense here
      ? should we direct pipe somewhere at the end?
        `list <| #*2 <| filter(#) |> list`
      ? ~~should we instead use `|>` as direct pipe and `<|` as inverse "writing" pipe?~~
        - `list[10..20] <|= # * 2` is `list[10..20] = list[10..20] <| #*2`
        - `list[10..20] <| list[30..40] |> # * 2` is confusing
    ?- how do we indicate index?
      ? ~~`list <| (*i=0, *prev; >i++, >prev=#;)`~~
        + !clever!
        - requires stateful varis per-block, not per-function
      * just use variable `i; list <| i++`
    - no intuitive way to make reducers `a..b |> #0 + #1` ?
      + reducers are anyways very similar to regular loops

  ? ALT: `(list:x <| x * 2):x <| filter(x)`, `a < 2 <| a++`, `list:x <|= x * 2`
    - doesn't allow nice chaining
    + most compact way to write element of list
    - conflicts with named fn arguments

  ? ALT: `list <> # * 2 <> filter(#)`, `a < 2 <> a++`, `list = list <> # * 2`
    - doesn't have pipy look

  ? ALT: `list |> # * 2 |> filter(#)`, `a < 2 |> a++`, `list = list |> # * 2`
    + natural pipe symbol
    - `a |>= # * 2` is unwieldy

  ? ALT: `list -> x <| x * 2 -> y <| y * 2`, `list -> x <|= x * 2`
    - same cons as `list -> x :: x * 2`
    + allows chains `list->a <| a*2 ->b <| b*2`
      - chains are not easy to read
      - haskely construct
    + allows detecting iteration procedure

  ? ALT: `list <| x, i -> x * 2 <| y -> y * 2`
    + very natural reference to mappers
    + allows optimized reducer op as `0..10 |> (cur, sum) -> sum + cur`
    + no namespace pollution
    + allows internal vars as `list <| x -> 0..x |> (y, sum) -> y + sum`
    + familiar chaining
    ?+ `0..10 <| 0` enables just filling with single value, like `[0..100 <| 0]`
    + assignment/map as `list <|= x -> x * 2`
    + indicates item index naturally
    + a bit more neatural break/continue
    - shadows global variable names with local args, same as function
      - which creates an alternative notation to a function
      - creates question if funciton reference can be used instead of mapper (answer is no)
      - function naturally creates scope, and mapper here doesn't
        - in other words, `x; vals <| x->` acts as `var x; for (x in vals)`
    - fold & map are very similar by implementation `a,b,c <| x ->` vs `a,b,c |> x ->`

  ? ALT: no range / list loops, only while loop
    * `i=0; 0..list[] |> list[i] + list[i-1], i++`
      + syntax tax is minimal
      + no global shadowing: everything is clear
    ? list comprehension problem
    + solves fold/map conflict
    + solves problem of condition in lhs

  ? ALT: `x =~ list`
    - nah: `x = ~list`
  ? ALT: `x <~ list : `

  ? ALT: `<( x>2?!; )>`

### [x] Loops: What's the best character for topic placeholder? -> `_` means "insert here", also it's terminal caret

  * `list |> #*2`, `list |> #>2?^^#:^#;`
    + `#` is almost perfect for topic/reference, associates with `#`th item
      - pipe is not loop, it's "previous expression output insert here"
    - has more meaning as "number of" rather than i-th number
      ~+ current item number as well
    + has typographical meaning as placeholder, or "insertion field"
      - less of "insert here" more of template
    - needs prohibiting variables starting from # though
      - which is problematic for mono buffers `#tri = [..1s] <|= tri(# * 2)`
      ~+ no, doesn't need, why?
    -~ interferes with `<math#a,b,c>`
      ~ these imports are unwieldy tbh, too much legacy mixup: JSX, C++, types, URLs.
    + no "select-all" problem as acute as with `_`
    - can be used for some actual operator rather than variable placeholder
      ~ unless we allow `#` as part of variable name
    - has strong flavor of directive (C++ etc) or comment (Python etc)
    + easier to scan visually, compared to `_`
    - has some sense of global declaration. We may want to reserve `#` for declarations purposes
    - too heavy semantic load from other concepts, like comment in python, hash in HTML, tags, private in JS, markdown header

  * ~~`list |> &*2`, `list |> &>2?^^&:^&;`~~
    + & is almost-character, feels more like an id
    - has weird connotation as binary
    - makes `list |> ^^&&&` a valid construct, ugh
    - there's too much meaning for `&` character as `&`, `&&` already
  * ~~`list |> @ * 2`, `list |> @>2?^^@:^@`~~
    + relatively safe
    + associates with id / character
    + not reserved by other meanings
      -~ import
    + allows reserved name, no var name like `#` shadowing
    + `items |> filter(@)` looks softer than `items |> filter(#)`
    ~- unusual convention (no such precedents)
    - conflicts/associates with import (import can be `<>`, but still)
    - makefile denotes `$@` as target file (exports?), and `$^` as current file
    + matches `au-` from language name, also looks like aura around a
      - we don't use auro name
    - no confidence in it
      - looks too much to reserve for that lil task
      - no "placeholder" or "insertion" feeling
      - associates with some mystical meta-stuff like decorators or directives
    - can be reserved for params descriptors aka jsdoc `;; @t ‚Äì time`
  * `list |> _ * 2`, `list |> _>2?^^_:^_`
    + less mystery than with `@`
    + more conventional (Elixir, Julia, Scala, Perl, PowerShell)
    + not an operator anywhere
    + literally means "insert here" like in written forms for fields
    - not as distinguished from code, as `^@#&`
    - select-all problem, esp. since default separator in vars is `_`, like `sin_w`
      ~ not necessary, since we are likely case-sensitive
    - has tinge of "throwaway variable"
      ~+ we don't need throwaways, since we support skipped args `(,,)`
    - has tinge of "private variable" (locals)
      ~+ it's private in a way
    + literally means "placeholder", for "placeholder" variable
    + we don't have special designation for lowdash otherwise
    - HARD to scan - it doesn't look like id, compared to `#`
    + it's caret in old terminals, meaning literally "insert here"
  * ~~`list |> ^ * 2`~~
    - conflicts with `^` for return `list |> ^>2?^^^:^^;`
    + compatible with js proposal; compatible with makefile;
  * ~~`list |> ~ * 2`~~
  * ~~`list |> () * 2`~~
  * ~~`list |> . * 2`~~
    - conflicts with export
    - field is taken by `..`, `.` as export, `x.2` as prop, `.2` as float
    - hard to select-all
    - reminds tits `a(.)`
    - `...`: `. ..` or `.. .`?
  * ~~`list:x |> x * 2`, `list:x |> x>2?^^x:^x`;~~
    + differentiates `a > 1 |> x` vs `a : x |> x`
    - conflict-ish with step `0..10:0.5:x |> x * 2`
      ? `0..10 + 0.5 : x |> x * 2`
    - conflicts with condition `a ? x : y |> z`
    ? not clear for individual items `(a,b,c):x |> x * 2`
  * ~~`list<x> |> x*2`, `a,b,c<x> |> x*2`, `0..10<x> |> x*2`~~
    + Sercy sneezed
    + matches graphics of loop
    + allows defining multiple variables `a,b,c <x,i>`
    - syntactically horrific
    - reminds type templates from C, which it is not
  * ~~`<list:x> x*2`, `<0..10 : x> x*2`~~
    -~ `<list: (x>x*2);`
  * ~~`list <x> x*2`, `a,b,c <x> x*2`, `0..10 <x> x*2`~~
    - `(list < x) > x*2`
  * `list |x> x*2`, `a,b,c |x> x*2`, `0..10 |x> x*2`
    - `list | (x > x*2)`

## [x] Loops: What's the difference of `list <| # * 2` vs `list |> # * 2`? -> multiple vs single return, we don't need <| if we detect if returns are necessary

  ? First one returns multiple members, last one returns single (last) value
    ? can we detect that by-use-case?
      - unlikely, same use-case can include both `[0,1,2<|@*2, 0,1,2|>@*2]`
    + first uses heap, the second doesn't (is faster)

## [x] Loops: `list <| x` vs `a < 1 <| x` - how do we know lh type for while loops. -> .. |> (cond ? ^;)

  * type can be unknown, like `x(arg)=(arg <| ...)`
    ? do we run it until condition holds true?
    ? do we consider argument a list?
  * Figure out condition from op in left part: `a < 2 <| #`
    - what if left condition is dynamic: `item <| item = nextItem()`

  ? `list[..] <| #`
    ~ supposedly creates iteration subbuffer
    - `[1,2,3] <| #` would need to become `[1,2,3][..] <| #`
    - anything on the lhs will be multiplied in pipe expression
  ? `a < 1 ? <| a++`, `list <| #+1`

  * it seems whatever type array arg has as a data, that's not what we intend: we should not waste time on detection

  ? ALT: `#` means iteration, `list <| #+1` is iterator, `list <| 1` is while loop.
    - not explicit enough that `#` somewhere in rhs is iteration

  ? ALT: `list |> # + 1`, `a < 1 <| a++`
    - that's same loop, separating operators is confusing

  ? ALT: `list#item |> item + 1 |> item + 2`
    - pipe is not connectable

  ? ALT: iteration is always via ranges
    * `.. <| # + 1` for infinite loop - break if needed
      + `.. <| # < 3 ? ./;`
    * `..100 <| #` for limited loop
    * `0.. <| # + 1` another kind of limited loop with nicer id
    ? `..(a ? 1/0 : 0) <| a + 1`
    + refers to `..` in more looping sense!
    - no while is a bummer

  ? ALT allow condition on the left side? `a < b <| ...` is boolean op on lhs
    + enables simple while loops
    + allows prohibiting infinite lhs ranges
    + detectible from input arg as boolean operator
      * it would need special boolean indicator for ops result. (any condition)
    - `1 <| ...` will produce infinite loop
      ~ we would not consider it a boolean op, it'd need to be `!0 <| ...`
    - breaks convention of iterating left side items

  ? ALT: prohibit iterating lists: only range `a..b <|`, sequence `a,b,c <|` or condition (while) `a < 10 <|`
    + it's trivial and more explicit to iterate loops as `0..arr[] <| arr[#]`
      + it's also more useful for reducers/prev refs `1..arr[] |> arr[#-1] + arr[#]`
    + it's more explicit and close to low-level what's going-on
    - prohibits `x[1..10] <|= # * 2`
    - breaks pipe `0..items[] |> filter(items[#]) |> gain(items[#])` is super-verbose

## [ ] Arrays: How to represent array (pointer) in code? -> ~~let's try f64~~

  1. Use multiple stack values?
    + allows returning arrays as a couple [ptr,length] instead of storing length in memory
    * see https://hacks.mozilla.org/2019/11/multi-value-all-the-wasm/
    + allows creating multiple buffers from same memory part
      + length should not be stored in memory
    - enforces functions taking array arg to convert into taking 2-args (ptr + len), which doesn't convert to js well
      ? how much do we need to have access to raw memory from JS side?
    + the most reliable solution in terms of precision/scalability
    +? allows kind-of detecting array argument. How?
      . easy from callsite, but how externally detect that the arg is array?
        ? prohibit external array args?
          + we don't expose implicit memory to JS: explicit export
          -? how do we do processing then?
            ?+ export global array, write to it, read it?
              ?- do we ensure singleton exportable global memory then?
                - that single memory contains a bunch of internal info: no way to give ptr/length
    ? still not clear - how do we know if arg is an array or f64
      + by-operator, as we do now with ints/floats
    - not clear which fn argument can be an array, even from call signature `a(arr, b, c)`
      -> arg must be only one
  1.1 We reserve special types sequence eg. `(i32, i32)`

  2. structs `(type $ptr (struct i32 i32)) (func (param (ref $ptr)))`
    - unknown when structs will be supported
      ~ it's supported everywhere already
    + standard way
    + no memory burden
    + returns JS arrays
    - involves GC, which might be not good
      - may complicate compilation to simpler embedded envs
        - eg. not supported by wasm2c
    - what do we need memory for then?
    - if we involve structs, we may as well use arrays directly

  3. funcref returning ptr and length upon call?~~
    + we anyways read length via operator
    + can store these variables anywhere, not just memory
    ~- not any js fn can be passed
    + can be stored in separate table
    - requires memory variable to be exported to get pointer at it
      ~ maybe unavoidable if user needs to import memory
    - not sure if we can create functions in runtime
  4. can be fn getter/setter that writes or reads value of the array~~
    - not sure if we can create dynamic functions with local state...
  5. use `i64` to store both array pointer and length.
    - returns BigInt, which needs to be reinterpreted client-side to get pointer to memory, not obvious how
  6. use `f64` real/fraction for address/length
    + wider addr/length range, up to `2^52` of int values
      - it may be not as good as `2^25`, consider storing length as `i16` (32756) - not so much, but already 52-16=36 bits for array length...
        ~kind of fine still, we can store fraction as the right part of float, at the very end
      - generally it's precision scaling problem
    + possible to use as ptr directly in JS `new Float64Array(memory, ptr, ptr%1)`
      - length is non-trivial to figure out
      - data type is not accounted for
    - value needs to be checked somehow if that's an array = we don't have clear understanding if that's an array or float
      ?+ we can avoid value check if we consider it an array by-operation, so that all array ops are non-overlapping with math. Eg. `a |> b` and `a ~ b`
        + we just enforce lhs `a |> #+1` to be a list
        + also, we force `a[..] |>` for pipe loops
    + to get length: reinterpret f64 as i64; apply length mask 0xffffff; wrap to i32.
    * if we stick to this, essentially it means any number becomes memory pointer
    ~- any number for `|>` operator is treated as memory pointer, which might be undesired effect
      ~- we may expect `3 |> # + 1` to be loop of 3 items
        ~+ it's sort of fine to treat it as `3.0` and just skip looping
      ~ `3.000xxx |> _ + 1` means iterate memory at offset 3 for 14 elements
        ?+ kind of useful for logging memory state?
        + kind of reinforces notion of singleton-memory
        + can be useful for sound hackers - iterations of fragments of waveforms (granular synth) etc.
      + since we limit pipe to `a[..]` that means we prevent too obvious hacking this way
        - passing arbitrary number instead of expected array opens up access to memory
    ~- some dec combinations are impossible, eg. `1.102` turns into `1.10200000000000009059`
      + we need to encode int24 into fractional part as binary, allows up to 99999999 memory address value

  7. v128
    + throws at times ensuring arrays belong to piezo, not outside
    + properly stores 4xi32 for tech purposes: address, length, data type, shift etc
    - fn arg requires to be indicated somehow via syntax, like `a(x[])`
      + that gives slight type definition, which facilitates handling them
      + that definition would be helpful with vars as well
      ~ drawbacks of `x[] = y` form
    + no unnecessary conversions to get value
    ?- how to interact with arrays from JS side?
      ~ we'd need special function
        + we may need it anyways, if we enable dynamic values via heap
      + global v128s are exported fine, we can just read them as `array(gv128)`
      - functions can return a tuple for v128, since v128 directly throws an error
        ~ we may prohibit returning arrays in exported functions and limit exchange to (global) memory only
    - requires SIMD
      ~+ available almost everywhere

  8. track all known array ptrs in a table/memory or just as global vars
    + we can represent them single-var via just id, not actual pointer
    - we can do infinite slices, storing all of them as ids is impossible

  9. Use WASM GC
    + supported by all wasm engines
    + direct returns in JS side
    + uncontaminates memory, no heap required
    - involves GC
      - less portable

## [x] Arrays: Prohibit dynamic arrays `a()=(x=[1,2,3])`? -> keep them, but dispose immediately once ref is lost, statically

  + ensures static memory: doesn't grow cept comprehension
  -? we can track & dispose them by the end of function call ourselves...
    * if array is returned the ref is lost
  + we can track all arrays, including stateful, static-time
    ?+ callsite is supposedly fully predictive: there's no chance for arbitrary new callsites, is there?
  + we can slice existing memory easily
  - we can declare memory size in advance by just `[1,2,3]`

## [x] Arrays: List comprehension: how? -> via heap

  * The size of final list is unknown in advance. It requires dynamic-size mem allocation.
  ? Can we detect size in advance somehow?

  1. We can reserve memory slot for dynamic ops and perform various stuff there
  2. Alternatively we can create large-dynamic slot for the time of array init, then dispose unused after init
  3. Just create new array and push members to it, increasing array's length. We suggest there's only one dynamic array at-a-time created, so it's safe to increase length on creating time.
    -> Or better just write length after the array is created, eg. somewhere in dynamic `$alloc` method.

## [x] Arrays: Create empty array - how? -> `[..10]` since range is exclusive

  * `[..10]`
    - not clear if that's 10 members from 1 to 10 or 0 to 10 or what
      ~+ with enforced 1-idx convention it doen't make sense to have anything below 1
    - confusing, since range starts with minus-infinity
    + a bit hacky = non-main way to create blank list, ie. values can be heap-y

  * `[1..10 <| 0]`
    + very explicit
    - verbose
    + protects from not-zero values
    - requires initializer

  * `[0..10]` creates empty array instead of raising seq
    - not how range maps to group

  * `[15]x` creates `x` as array
    + gives static indication of var/argument as list.
    - sabotages whole concept of `x = [1,2,3]` as `[]x = (1,2,3)`
      + which can be nice since can replace concept of buffers with just lists
      + this avoids `m = [n[1..3, 5, 6..]]` as `m[] = n[1..3, 4, 6..]`
      - nah, `[1,2,3]` is too nice to avoid
    - introduces new operator
      * (set length? a bit weird/unclear outside of declaration, eg. `[10]x = (1,2,3)`, `x = [10]y, [10]x = [1,2,3];`)
    + returns newly created array, not array property

  ** `x[0..6];`
    + same as just declaring variable, but immediately declares a list
    + removes the whole syntax concept of `[a,b,c]`
    - discards position aliases
      ? can be done as `x[2,-1] = (third:3, last:-1); x.third; x.last;`
      ? alt: `x[third:2, last:-1] = (3,-1); x.last`
        + then `(third, last) = x[..];`
    - `x[2..4]` doesn't make any sense for initializing buffers
      ~+ can just refer to items to prefill, eg. `x[5] = 0` or `x[2..3] = 4,5`
    - `x[4]` creates buffer of 5 items
      ? unless we make 1-based indexing
    + if we drop named args/array members we can save `:` operator for later uses
      ?! can be used for clamp or var range indication? like type definition but more meaningful
    + solves issue of table of funcs definition: `funcs[..] = (a()=(), b()=())`
    - iteration is available as `x <| #` and `x[..] <| #`
      ~+ first case it's list iteration, second case it's group iteration
    - declaring fn argument `gain(out[])` vs `gain(out[1024])` vs `gain(out)` - not clear the difference
      ~ `x(out[])` is meaningless,
      ~? `x(out[3])` creates array of 3 if arg is not provided
        ? alt: it writes argument to 3rd position in `out` local variable
    + reduces the necessity of 0-based indexing since list becomes a bit more hi-level thing
    - inconsistent: expected to return an array reference, but returns value of an array instead
      - so that if we want to return just created array, we'd need to `x[10];x;`
    - creates not very nice condition in code of property access.
    - enforces 1-based index for list elements

## [x] Arrays: Should we keep immediate list notation? -> yes, let's keep

  + Allows passing memory area directly `gain([1,2,3])`
  + Enables nested lists for tree structures, unlike groups `[1,2,[3,4,[5]]]`
  + Looks more natural

## [ ] Arrays: How to create subarray? -> ~~@latr.sublist or directly math `y+=2; y[]-=2;`~~

  * `x[] = y[1,2..3]`
    - syntactically creates copy of y
    - writes to x's length

  * `x[10]; y = x + 3;`
    + mathematically correct
    + keeps proper offset
    - may need to have special fn to change length, since uses reinterpreting
    - knows about pointers
    - super confusing to represent array as number

  * `x[10]; y = @latr.sublist(x, len: 3, start: 2)`

  * `x[..] = y[..]`
    - writes into x

  * `x = *y` for copy array, `x = y` for subarray
    - subtle conflict with C's pointers
    - in Kotlin `*` is for spread

  * `x = y[..]`
    - ~~takes first item from many~~
    - attempts to iterate through array

  * `x = [10..]y`
    - weird syntax

  * `x []= 10..`
    ~ kind of valid self-slicing
    - loses reference to initial list
    - means `x = x[10..]` would create reference, not clone

## [x] Loops: Should loops return multiple arguments? How to maintain the heap? -> `<|` returns multiple members to heap

  + allows `fn(list <| @ * 2)`
  + allows `[(a,b,c) <| @ * 2]`
  - internal lists `list <| (0..@ <| 2)` becomes problematic to create in memory

  * ALT: We don't make loops return multiple arguments and just one (last argument)
    + solves issue of dynamic args
    + compatible-ish with JS
    + removes question of dynamic members type
    - list comprehension is unavailable
    - we may possibly need heap for other things besides loops, like `m[2..] = (3,4,5)`

  * ALT: it might be possible to maintain nested multiple results
    * we use heap area to avoid clash with static arrays
      * we cannot merge heap and memory, because if internal dynamic array is finished, it must be put in static memory
      * besides multiple memory proposal allows to fix it nicely
    * when we're generating dynamic args, we save heap start address and len variables
    * when we've finished generating multiple args - we either copy them / send to stack and discard heap
    * we continue previous heap

## [x] Loops, conditions: how to define block -> deal with precedence of `|>` and `?` operators only, they're lower than commas.

  * these are apparently a separate syntax group
  * these operators may require lower precedence than `,` or even `;`: `a ? x(), y(), z()` - these are elements of array, but not part of a condition.
    ~ can be done as `a ? (x(); y(); z())`
  * one possible simplest loop is without any condition, only by breaks `(a() ? x.; b(); c() ? y!;)`

## [x] Heap strategy: tail or head -> let's use head with compile-time heap size detection: heap is just static array in memory

  * Head: `[ Heap | Static... ]`
    + easier offsets (no need to track beginning of heap)
    - overflow risk: silently rewrites static memory
      - checking boundaries on each write would be expensive
        ~ that's risk only for comprehensions: we can check limits in `range_alloc`, `alloc` or
          + list comprehension can know max input length in advance, except for open ranges like `0..` or `..`
            + we'd anyways do something like that to prevent infinite loops
          ~ so heap size would need to be detected compile-time
        ~? ~~we can flush heap into static memory by parts, no need to wait for overflow~~
          + that allows smaller heap size and no need for customization
            - that makes code generation problematic and verbose (multipart case)
            - internal arrays mess up sequential heap
    - fixed-length heap
      ~+ it's fixed anyways in most of the cases, we can do 48000 something (6-10 pages)
    + no need to maintain heap base offset, since it's always 0
    + no need to displace heap all the time: it seems if we create dynamic array we'd copy heap O(n) times - crazy
    + gives better values for array refs - we can just ignore values `< HEAP_SIZE` in iterators, so that userland floats like 10.000012 don't make any point
    + gives nicer calc for mem.alloc - no need to discount heap - mem pointer can reserve heap as "first static array" lol
    - low locality: once heap increases all array refs are lost
      ~ not sure if that's dangerous
      ~- programs with same memory but different heap don't share array references
    + gets easily fixed once multiple memories hit in
    - allocs heap per audio-node which is too excessive

  * Tail: `[ Static... | Heap... ]`
    + heap overflow throws error automatically
    + no risk of rewriting static memory
    + we allocate static memory in blocks, so heap can be eg. at the beginning of the next page, so we move it only when static memory grows
      - needs memcpy to be called for heap
        + heap is small, so memcpy should be fine
    - heap is still fixed size
      ~+ check can be added to simply grow available heap once heap limit is reached
        ~ that check can happen per-heap alloc, so that we ensure max length per allocation, not total heap size

  * Dynamic head: `[ Heap... | Static... ]`
    - memcpy static once heap grows
      + heap grows rarely, unlike static, since it's more like tetris - once arr is filled it destroys
    - requires hard heap limit anyways to prevent infinities
    - once heap grows all array refs are lost
      - we need to store refs as relative

  ? do we actually need growing memory?
    + limited memory ensures portability
    - we can't limit it to some huge block by default, we need it to be able to grow to some extent
    + max array length is limited by-design to i24, which is 16M of els (f64s), which is 2048 pages of memory
      - so it's an overkill for simple tiny programs to limit to such huge numbers
      + same time it's good point to generally limit memory

  * No heap `[ Static... ]`
    + There's a way to comprehend arrays directly in static memory
      + We just don't init internal arrays immediately but save their location and defer init, when the length is known
        ? `[1, 2..x, [3], f()]` - how do we know location of `[3]`?
          * `a=[1, 2..x, #1, #2]; a[a~<#1] = [3]; a[a~<#2] = f();`
        ? `[0..x <| x -> (!x ? ^; [..x]), y]` - how does that work?
          * `a=[0..x <| (x,i) -> (!x ? ^; #i)]; 0..x <| (x,i) -> (!x ? ^; a[a~<#i]=[..x])`
        ? `[a=2,b=[..a],c=b[..]]` - how?
          * `x=[#1,#2,#2]; x[x~<#1]=a=2; x[x~<#2]=b=[..a]; x[x~<#3]=c=b[..]`
        -? `[0..x <| [..x++]]` how?
    - debugging these is laborous
    - perf tax finding index
      ~+ we don't know memcpy tax from head method
    - we need heap to iterat `(a,b,c) <|` - there's no way to do that via stack (it seems) since loop enforces params

  * Mixed no-heap as much as possible, otherwise heap

## [x] Import: no-keyword? -> ~~`<math#floor>`~~ let's hold on for now

  * No need to define scope: imports full contents
  * `#[math]; #[./path/to/lib.sy];` (Rusti)
  * `#math; #./path/to/lib.sy;`
    + like md title
    + shortcut from #include, #import in C, C++, Obj C
    + `# 'math': sin, cos;`
    + shebang starts as `#!`
    + music sheets start with # and b
    + similar to Rust
    - conflicts with cardinality (number) operator: #str literally means number of items in string.
      ~ we don't have cardinal operator
    + associates with declaration, something global, outside of program
  * shebang `#!'math'`
  * ... 'math', 'latr', 'musi';
  * << 'math', 'latr', 'musi';
    + (mathematica, wolfram)
    + C-streams like
  * ! 'math', 'latr', 'musi'
    + matches doctype delcaration
    + reversed i
  * <'math', 'latr', 'musi'>
  * :: 'math', 'latr', 'musi'
  * > 'math', 'latr', 'musi'
    + quote in md
  * {{math}} {{latr}} {{musi}}
    + like django templates
  * {'math', 'latr', 'musi'}
    - occupies sets convention
  * `& 'math', 'latr', './my.son'`
    + semantically makes point as "with math"
    + et ‚âà include
    - no easy way to scope imports
    - might be occupied by state

  * `@math: sin, cos; @latr; @./my-lib.son`
    + literal meaning: at math: sin, cos;
    + @ has address intuition, which better fits for paths.
    + very typographical natural convention.
    - doesn't allow sequence `@math:sin, @latr, @@audio-lab/synth, @./path/to/my/lib.sy;`
    - double `@@audio-lab`
    - reserves `@` and `:` operators.
    - disregards URLs.

  * `sin, cos @ 'math', * @ 'latr'`
    + a,b at source
    +~ reminds npm namespace convention
    + CSS @import, Objective C @import.
    + relatively exceptional character, compared to #, :, &
    - conflicts with npm namespaces `osc1, osc2 @ '@audio-lab/synt'`
      ~ we may not necessarily want to resolve node_modules path, it's going to be either just `synth` or full path.
    + no case-sensitivity problem, `math#PI` and `math#pi` are different
    + it's more obvious that variables become part of scope, rather than figuring out vars from atom `'#a,b,c'`

  * `<math>, <./path/to/my/sound.sy>, <@audio-lab/synth>, <inline-url>;`
    + associates with C's `#import <std>`
    + encloses internal stuff: it's not string nor expression, same time safe
    + frees extra operator `@`, `:` - allows `#` internally as part of URL
      + can be used for defer or privates
    + reminds brackets in terms of "include here"
    + relatively rare to use for anything else
    + allows protocols inside as `<https://sonr.io/kick.s#a,b,c>`
    - looks like JSX/C++/TypeScript type templates
    - multiple lines in a row look heavy `<math#pi>;<./path/to/lib.sy>;`
      + allows sequence as `<math#pi>, <./path/to/lib.sy>;`
    - not as natural as `@math:sin,cos; @./path/to/lib.sy;`
    - reduced to none becomes `outside` operator `a <> b..c`

  * `{math},{./path/to/lib.sy},{@aydui-lab/synth};`
  * sin, cos <- 'math', <- '@audio-lab/synth'
    + reminds list comprehension with assignment
    - conflict with arrow function ->

  ? is there a change we're going to need to include generic binary fragments?

  * importing all is not nice pattern: that causes implicit conflict.
    * it's better to always assign to a variable to make importable parts explicit.
    - conflicts with notes. We need to import all of them.

## [x] Import: subparts ‚Üí ~~try `<math#floor,cos,sin>`~~ let's hold on

  1. `@ 'math': sin, cos`
    + defines global functions
    + less problem scoping imports

  2. `@ 'math#sin,cos'`
    + [qwik](https://www.builder.io/blog/hydration-is-pure-overhead)-like
    + URL notation
    + SVG `<use href="#ref-to-part">`
    + no `:` overloading.
    - global functions come as part of atom
      ~ they're not really global
      ~+ can be rethought as `<math#sin>` - not so much part of atom.
    + easier to type
    - list `#a,b,c` is non-standard-ish.
      ~ google uses it like that
      ~ the most natural way
    - disallows spaces: `@ 'math#pi,sin,abs';` looks messy, if imports many items
      ~ maybe that's nice, since it's not full-fledged syntax anyways
      ~ besides URLs are like that yep, have a look at font imports.
      + smaller
      ~+ doesn't have to be single-string in case of `<>`, can safely do `<math#sin, pi, abs`
    + looks cleaner as a single "addressing" token.
    + easier to indicate "import all" as just `@ 'math'`

  2.1 `@math#sin,cos`, `@./path/to/file.son#a,b,c`
    - messes up with native syntax - paths are not part of it.

  3. `sin,cos @ math`
    + sounds nicely
    + obvious definition of global module variables, not some part of atom
    + similar to assignment by order
    - scoping problem, same as JS.

  3.1 `math @ sin, cos`

## [ ] Import: should we delegate it to compiler options?

  + no need to care about file loading method: left up to user
  + no syntax questions
  + no code noise
  + sonr can make some default math convention for imports, as well as export
  + we anyways have to provide imports in compiler options, so that's unnecessary in code
  - introduces implicit environment

## [x] Import: Do we need to have `@` for imports? Can't we just indicate atom directly? -> we can import without atoms

  ? Can we do directly `'math#sin,cos'`?
  + saves from `@'@brain/pkg'` case
  + frees `@`
    - maybe we don't need too much diversity in var names, `#` for arrays, `_` for privates and `$` for specials is enough
  + less cognitive load, very simple
  + less characters
  - reserves atoms for single-purpose use, better keep them for generic escaping non-codes?
    + case-insensitive code doesn't make point for quoted values
      * so qotes only act as separators from regular syntax, not literal strings
  - some imports can be without quotes, like `@math#pi;`
    + less separation from code

## [x] Import: into function scope? -> no, too big of a workaround for wasm imports

  * `saw() = (<math#pi>; pi*2+...)`
  + allows avoiding conflicts
  ~+ seems unavoidable if we introduce with `list:a,b,c` operator
    - we don't;
    - also we don't have array aliases.
  - conflicts with the way imports are done in wasm

## [x] Import: JS things? -> yes, import only via JS, hold on with importing files

  * Must look more like a native object
  + `@math.pi` can be directly mapped as `(import "math" "pi")`
  + allows hiding particular file mechanics, making imports fully JS-thing
    + makes musi, latr and others just wasm libraries for lino, they can be written in any form/language, even JS
    + makes `#` part of var names
    + allows avoiding quotes

## [x] Import, Memory: Should we make memory importable, instead of exportable? -> internalize memory - it is exported only if imported

  + naturally enables shared memory
  ? can help with question of naming memory?
  + can be, yes, as `compile(src, {memory})`
  ~+ we gotta need to provide means to work directly with memory
  -> can be defined via config

  ! if user needs to read memory - he must pass it as import argument; if memory is not passed - it is internal and there's no way to read it.
    - useless to pass memory object in advance only to know mem signature

## [x] Import: Directly call imported items as `@math.pi`? -> no: makes code unnecessarily verbose

  + so js does.
  + nicely separates namespace
  ~ so to import into a namespace we'd need to `(pi, sin, cos) = @math`
    - not fully compatible with buffers, eg. `(a,b,c) = [c:1,2,3]` takes sequence
    - not compatible with the way groups work: `(a,b,c) = x` assigns `a=x,b=x,c=x`
    ~ it'd be `(pi,sin,cos) = @math[..]`
      - confusable with lists still
    ? `{pi,sin,cos} = @math[..]`
      + makes sense as sets/enums
      - introduces whole sets concept
    ? `(pi,sin,cos) = @math.*`
      - introduces blobs, meaning is similar to `[..]`
    - it is sort of shadowing, which we don't welcome.
    ? Maybe we should just prohibit destructuring imports? Like, everything is very explicit and self-contained?
      ? destructuring of internals must be also possible: `(ABC, CDE) = @musi.chord`
    ? What if `(pi, sin, cos) <= @math`?
  + makes `@` part of name with special meaning
  - makes code very verbose
  - C/CPP doesn't do this way

  ? what if `pi@math`?

  * if we make import as `@math:x,y,z` then `list:first,last` acts as destructuring as well...
    * same as `(x,y,z)=@math.(x,y,z)` or `(first:first, last:last) = list`
    - we already have `list.first`, `list[0]` - making also `list:first` adds to confusion
      ? can we lower precedence of `.` so that `list.a,b,c` returns 3 items?
        - nah, `list.a, b, c` that is
    ~ makes `:` local operator, eg. `(list:first,last; first+last)`, so `(@math:sin,cos; sin(x)+cos(x))`
    ~ narrow version of `with` operator, that takes list of items to expose
    - `lib:a,b,c` has precedence conflict with `fn(a:1,b:2,c:3)` and `[first:a, last:b]`

  ? Should we just keep `(x,y,z)=(@math.x,@math.y,@math.z)`? Can we optimize it?
    * `(x,y,z)=@math[x,y,z]`?
      ? `(a,b,c)=list[0,1,2]`?
    * `(x,y,z)=@math.(x,y,z)`?
      ? `(a,b,c)=list.(0,1,2)`?
    * `(x,y,z)=@math.;`?
      ? `(a,b,c)=list.`?
    * `(x,y,z)=@math[..]`?
    * `(..x,..y,..z)=@math`?
    * `x,y,z @ math`?

## [x] Labels `a:1, b:2` vs imports `a: b,c` -> we need neither of them

  - ~~`[a:1, b:2]`~~, `fn(a:1, b:2)` and ~~`(a:1, b:2) = x`~~ "hold hostage" the following operators:
    * `list: a,b,c`
      + if we prohibit named lists, this disappears
    * `@mod: a,b,c`
      + if we opt out of named lists, we essentially introduce `:` for only imports
        + we likely don't need `@a:b,c` imports
    * `^ a,b,c`
    * `a,b,c <|`, `a,b,c |>`
    * `a,b,c -> a,b,c`
    * `x ? a,b,c;`
  - we're not able to implement array aliases: arbitrary argument can be an array, some arrays have aliases others not
    , we're not going to make aliases dynamic
  - destructuring `(a:1,b:2)=x` is therefore not needed, since we can't create array aliases
  - function named args therefore reserve a whole unique naming method `a:1, b:2`, which is not supported elsewhere.

  ? What are the alternative ways for named arguments ? Are they so much useful?
    + they increase readability
      - increase code size as well
    - `fn(a,,b,,,c)` - pretty terse and minimalistic way, compatible with arrays, to skip args
    - js doesn't have named arguments
    ~- if we pass args from heap as `x(x:1, 1..10)` then what? is there a conflict?
    - units also help separating args: `osc(3s, 1000hz)`, it would be too verbose to `osc(t:3s, f:1000hz)`
    ? we could do them as group `osc((t:3s), (f:1000hz))`, `adsr((a:1),(d:2),(s:3),(r:4))`
      ~ so `label:` works more as part of block/group as `(name: a,b,c)` rather than individual items.
        + which makes sense in terms of importing `@modul:a,b,c`

## [x] Import: Is it worthy introducing `:` only for importing members, ie. -> no, we use href as `<math#a,b>`

  1. `@math:sin,cos`

    + we introduce whole operator for exports: `a,b,c.`
    + it's very naturan typographic convention: `these: this, that`.
    ~ alternatively we just do `(sin, cos) = @math`
    - `@math:sin,cos` doesn't allow redefinition of names, it's hardly bound to "with"
      ~ we may not need aliasing - keep progs simple
      ~ we can just in case do `@math:sin=sin2,cos=cos2`
    - colon has types association lately
    ~ colon better associates with mapping: `@math#sin:sin2,cos:cos2`
      - nah, in lino we use `=` for mapping
      - also `a=b,c=d` is closer to cmdline args, `:` is more like specifier
    + CPP/C tend to import headers, meaning importing to global scope. It feels nice.

  2. `@math.sin, @math.cos`
    + explicitly indicates that that's external code
    + JS does `Math.sin`
    - `@math.abs` everywhere makes code verbose
    - `.` operator we use for static index access. Although it's common across langs for props, we may not support it.
      in other words, it breaks convention within lino.

  3. `@math#sin,cos`
    + allows files as href `@./std.ln#sin,cos`
      - takes access to files
    + decouples `:` from operator, making it more part of "string"
    - single operator is not enough for string. `<./std.ln#sin,cos>` would be safer

  4. no imports?
    - no library reuse
      ~ can reuse via manual copy-paste
    + self-isolated code
    + no unnecessary file access or bundling
    - imports is part of JS, code may be not known
    + good for embeddable systems since all code is known in advance

## [ ] Import: type detection: `@math.pi` vs `@math.sin()` - we have to detect type and fn signature. How? -> let's try passing config object for now

  1. By usage. `@math.pi * 2` - imports number, `@math.sin()` - imports a function.
    + we apply same logic in ops: `()` treats as fn, `[]` as array and `+` as number
    - `x=@math.pi; y()=(x+1)` - it can be a bit problematic to track status of `x`
    - `y(x)=(x); y(@math.pi);` - it cannot be ambiguous here.

  2. From import object (js side)? `compile(src, {imports:{...}})`
    - we don't have import object on lino compile stage...
    + it would be the most reliable since just function is not enough, we need to know signature
    + solves question of importing memory or possibly even a table
      ~ can be passed not polluting namespace
    + allows joining modules: `imports: {latr: ...src}` compiles latr source (necessary parts)
    - detecting function signature is problematic:
      - it doesn't discriminate `i32` vs `f64`
      - it doesn't detect multiple return arguments
    - it requires creating a memory object in advance for compiler, whereas it's required in instance

## [x] Variables: Should we make dot part of name, eg. `x.1`, `x.2`? -> no, it can be `a . 0`

  - likely no, since we use it in `@math.pi`
  - we don't really need member access generally

## [x] Variables: Changing variables type `x=1;x=1.0;` -> vars are always f64, operators can cast to int

  * that's problematic via wasm, since it enforces variable type: would be wrong to cast float to int
  ? upgrade type definition to float if it's ever assigned to
  ? declare float alias variable at the moment of finding upgrade
    + allows merging analyser into 1-pass compiler
    + retains precision

## [x] Variables: or do we represent infinity? -> `1/0`, `0/0`

  * `oo`
  * `~~`
  * `-/-`
  * `<>`
  * `><`
  * `..[-1]`, `..[0]`
    + technically correct
  * `0/0`
    + even simpler and more mathy
    + reminds actual infinity sign

## [ ] Functions: for references use i32? -> likely not, use regular fn refs if needed

  + we can hold both $x global and $x function name
  + i32 can automatically mean function reference
  + allows storing funcs in lists
    - we'd need to use NaNs with non-canonical form as list members
  - better use native func refs

## [ ] Use v128 of i64 for rational numbers? -> better off, use special float type

  + Converts back to f64 on export
  + Gives extreme precision/dimension
  + See android calc post - combined with units it can produce extreme precision

## [x] Ranges: exclusive / non-inclusive range: how? -> use `0..10` as exclusive, operators decide inclusivity

  * `0..<10`, `0<..10`
    - `0 > ..10`, `0.. < 10`
  * `min..(max-1)` for ints, `min..(max-.00001)` for floats, so basically no exclusive ranges
    + problem solved
    - span of int range is screwed up
  * exclusive ranges only
    + solves problem of range width:
      * take `1..2`, so `2-1` as floats gives 1 which is correct width, but gives `2` as integers which is wrong
    + initializing array as `[..10]` creates `10` elements this way from `0..9` inclusive
    + inclusivity is a matter of `<=` or `<`
    + no questions with the way `range()`, `clamp()` works
    - weird check `a in 0..10` is `a < 10 && a >= 0`
  * generally exclusives in langs are right `0..<10` or `0...10`, not making separate left `0>..10`
  * we can only have `0 .< 10` or `0 .> 10`
    ?- `x <> 0 .< 10` vs `x <> 0..<10`
    + have logic as `==` becomes `!=`, so `..` becomes `.<`
    + more laconic kind of
  * inclusive as `0..=10`, `0..10` is exclusive
    - `=` has wrong association, there must be `<`
    - `a.. = 10`
    + `Rust` has that
    + open-right range seems to be ubiquotous & mathematically standard
    -~ clamp is weird: `x <? 0..=10`
      ~ `x <=? 0..10` ?
        - nah, introduces 2 operators
      ~ or we can keep clamping to normal values `x <? 0..10` and keep range "exclusive" only for range constructor
    + follows the logic of `<` and `<=`
  * inclusive as `0...10`, exclusive as `0..<10`?
    - too lengthy
  * ruby's `0...10`?
    - `0.. .10`
  * `0..+10` for inclusive range, `0..10` for exclusive
    + `+` has no meaning as operator anyways
    - `10..-+10` vs `10..+-10` is weird, vs `10..=-10`

## [ ] Ranges: clamp symbol ‚Äì> f(x ~ 0..100=100, y ~ 0..100, p ~ 0.001..5, shape = sin) ~~`x = 100 -< 0..100, y -< 0..100` is more visually coherent and new, `~` is a bit too cryptic/old~~

  * ~~`f(x=100 in 0..100, y=1 in 0..100, z in 1..100, p in 0.001..5) = ...`~~
    - conflicts with no-keywords policy

  * ~~! Swift: non-inclusive range is 0..<100~~
    - see exclusive ranges research, confusable with `0.. < 100`

  * ~~`f(x{0..100} = 100, y{0..100} = 1, z{1..100}, p{0.001..5}, shape{sin,tri,tan}=sin )`~~
    + matches set definition
    - missing operator
    + allows defining limited variables `a{0..100} = b`

  * `f(x = 100 ~ 0..100, y ~ 0..100 = 1, z ~ 1..100, p ~ 0.001..5, shape ~ (tri, sin, tan) = sin)`
    + swift has ~= operator checking if value is within range
      * https://docs.swift.org/swift-book/documentation/the-swift-programming-language/patterns/
      ~- it's reversed order, `0..100 ~= a`
    ? shape ~ (tri, sin, tan)
      + matches direct groups
      + parens are just means to group items
    + ~ punctuationally refers to range, but direct ~ is too little info
    + shortest
    + has matching mathy meaning
    + it is very natural (up and down)
    +? `a ~/ 0..10` for normalize, `a ~* 0..10` for lerp
    + enables definitions like `x = 10 ~ 0..10;`
    ? what about smoothstep
      ~ likely we'd need to have a range modifier, eg. `x = 10 ~ 0..10**0.2`
    - not as piezo as `x = 10 -< 0..100`
      + still refers to piezo as "active current" or "wave"
    - `a ~* b..c` is also `a ~ *b..c`
    + ChatGPT suggests it as better option, since has built intuition
      - intuition is slightly off, it has not direct visual sense, and ~ means more "roughly", not "within range"

  * `f(x = 100 ~= 0..100, y ~= 0..100 = 1, z ~= 1..100, p ~= 0.001..5, shape ~= (tri, sin, tan) = sin)`
    + matches Ruby's regex-search operator, inversed
    + matches "equals" as "clamp"
    - isn't interchangable with `=`, has different meaning
    ‚Üí too much `=` noise - not clear associativity; `~` shows better contrast.

  * ~~`f(x = 100: 0..100, y: 0..100 = 1, z: 1..100, p: 0.001..5, shape: (tri, sin, tan) = sin)`~~
    + `:` is standard type definition
    - doesn't play well after value `x=100:0..100`
      ~ feature of variable/argument
    - interferes with named arguments
    - calculation-wise can be too heavy, compared to one-time clamp
    - has different precedence with `=`
    - has possible conflict with ternary

  * ~~`f(x = 100 ~ {0..100}, y ~ {0..100} = 1, z ~ {1..100}, p ~ {0.001..5}, shape ~ {tri, sin, tan} = sin)`~~
    + less digit-y as above
    - a bit redundant
    + allows sets
    - confuses of 0..10 and {0..10}
    + allows joining ranges {0..10, 20..30}
      ~ can be solved as 0..10 + 20..30
    - too curvy

  * `f(x = 100 -< 0..100, y -< 0..100 = 1, z -< 1..100, p -< 0.001..5, shape -< (tri, sin, tan) = sin)`
    + visually precise indication of what's going on
    + fork literally means from..to (in Russian at least)
    + allows `a -<= 0..10`
    + visually clear, in terms of noise
    + aligns with `-/` for smoothstep operator better than `~/`
    - `a-*b..c`: `a -* b..c` vs `a - *b..c`
      ~ same defect with `a~*b..c` as `a ~ *b..c`
      ~ `a - *b..c` has no much sense, star operator is used in declaration only
    + looks cooler than `<?` or `~`
    + ChatGPT suggests as visually distinct option
      - but a bit higher entry barrier to learn
    + it is a bit more consistent visually with `<>`, `><` than `~`, very strong clue
      + also it's a bit more in-sync with piezo style of "crystals" and "flashes", zz
    - it has too innovative twist, code looks overwhelmed with new stuff
    - there's confusion of `-<=` as `-< =` vs `- <=` - we stick to exclusive right member
    + grok recommendation https://grok.com/share/bGVnYWN5_362848bb-789a-41c4-8077-606787c712d9: crystal/flash aesthetic, less familiar, unifies with <>, ><, extensible to -*,-/

  * ~~`f(x = 100 <- 0..100, y <- 0..100 = 1, z <- 1..100, p <- 0.001..5, shape <- (tri, sin, tan) = sin)`~~
    + literally elixir/haskel/erlang/R/Scala's list comprehension assigner
    + stands in-place for "in" operator
    + similar to -<
    - `100 < -0..100`

  * ~~`f(x = 100 =< 0..100, y =< 0..100 = 1, z =< 1..100)`~~
    - we don't have operators starting with `=`

  * ~~`f(x = 100 >< 0..100, y >< 0..100 = 1, z >< 1..100, p >< 0.001..5, shape >< (tri, sin, tan) = sin)`~~
  * ~~`f(x = 100 <> 0..100, y <> 0..100 = 1, z <> 1..100, p <> 0.001..5, shape <> (tri, sin, tan) = sin)`~~
    + `x <> 0..100` means `x < 100 && x > 0`
    + visually intuitive, one of the first guesses
      + gpt suggested it
    + math charts for inc/excl ranges are like that
    + supports style of piezo operators `<>`, `-|`, `-/`, `-*`
    + makes smooths look less intimidating `-//`, `-**`
    + allows reverse clamp as `a >< 0..10`
    + visual logic
    - spaceship, not equal meaning already
    - `a = 100 <> 0..100` returns true/false

  * ~~`f(x = 100 <0..100>, y <0..100> = 1, z <1..100>, p <0.001..5>, shape <(tri, sin, tan)> = sin)`~~

  * `f(x = 100 <= 0..100, y <= 0..100 = 1, z <= 1..100, p <= 0.001..5, shape <= (tri, sin, tan) = sin)`
    + very natural & known operator `<=`
    + matches `element of` notation `<-`
    + no ordering problem with `<=` and `=`
    + frees `:` for technical needs, like import or named args
    - `x <= 0..3` means `x <= 0, x <= 1, x <= 2`
    + more meaningful for function arguments
    - less matching definition of `a < 10 ? 10 : a > 0 ? 0 : a`

  * ~~`f(x = 100 -| 0..100, y -| 0..100 = 1, z -| 1..100, p -| 0.001..5, shape -| (tri, sin, tan) = sin)`~~
    - looks too much like table separators
    + compatible `a -/ 0..10`, `a -* 0..10`

  * `f(x = 100 -: 0..100, y -: 0..100 = 1, z -: 1..100, p -: 0.001..5, shape -: (tri, sin, tan) = sin)`
  * `f(x = 100 ~: 0..100, y ~: 0..100 = 1, z ~: 1..100, p ~: 0.001..5, shape ~: (tri, sin, tan) = sin)`

  * `a |< ..10`, `a >| 10`

  * `f(x = 100 <? 0..100, y <? 0..100 = 1, z <? 1..100, p <? 0.001..5, shape <? (tri, sin, tan) = sin)`
    * `f(x<?0..10)=()`, `a >? 0..10`, `a <? 0..10`
    + meaningful shortened `a > 10 ? 10 : a`, `a < 10 ? 10 : a`
    ? logically clamp is `a > 10 ? 10 : a < 0 ? 0 : a` -> `a <?> 0..10` or `a >?< 0..10` or `a <>? 0..10`
      * or `a <? 10 >? 0` -> `a <? 0..10` meaning within, or less than
      + `a >? 0..10` means outside, not clear though which side
    - introduces `a <=? ..10` for inclusive test
      ? should we use `..=10` then instead?
    - intimidating look in arguments

## [x] Ranges: Element of range: `a in b`? -> likely ~~`a ~< (b,c,d)`~~ ~~`a <> (b,c,d)`~~ `a >< (b,c,d)`

  * Range can be iterable, so comparison can cause evaluation

  0. `x < 0..2`
    - `x < 0..2` is `x < 0, x < 1`
  1. `x ~< from..to`, `x ~< a,b,c`
    - `x <~ from..to` is `x < ~from..to`
      + `from..to ~> x`
    - conflicts with `x ~ from..to` for just clamp
    - heavy
    - doesn't play well with sets
    + logical in a sense referring to `~` for ranges
  2. `from < x < to`
    - makes comparison nary operator
    - destroys range, meaning it cannot be calculable
    - doesn't play with sets
  3. `x = from..to ? ^`
  4. `x <> from..to`
    - wrong direction of `>`: `x < from || x > 10`
      - in many langs this operator means "not equal"
    + can allow `x >< from..10`
    + natural suggestion
  4.1 `x >< from..to`, `x ><= from..to`, `x >< a,b,c`
    + right direction of operands `x > from && x < to`
    + intersection literally means one of elements
      + in -tersection means `in`
    + `<>` operator is reinforced by many languages as "not equal" or "outside"
  5. `from..to -> x`, `a,b,c -> x`
    + follows https://en.wikipedia.org/wiki/Element_(mathematics)
    ?+ can be used for loops: `x[..] -> i : i+1 : i + 2 => x[..]`
      - conflict with `i = a,b,c : i**2`
  6. `a ==|| (b,c,d)` for set comparison
    + `a == b || a == c || a == d`
    - non-conventional use joined operator, usually that's assignment
  7. `a ?:== (b,c,d)`
  8. `a -| b..c`
  9. `a <: b..c`, `a <=: b..c`
  9.1 `a :< b..c`, `a :<= b..c`

## [x] Ranges: Limited variables `x:0..100; x = 1000;` -> nah, perf-unwise

  + allows static tracking of value
  + compatible with arguments limiting
  - we don't have explicit clamp operator
    ?+ can easily `x > 10 ? 10 : x`
      ? can max be `x >? 10`
  - can be unexpected meaning
  - can slow down calculations, since performs runtime checks on every write

## [ ] Ranges: Range step -> likely 0..10:0.5

  * `[-10..10..0.5]`
  * `[-10..0.5..10]`
  * `[0..10 : 0.5]`
    + possible, : is free now
    + similar to type definition, but more meaningful
    + double-symbol refers to iteration
    - conflicts with brainching `?:` - meaning "code after branch" `a ? 0..10:0.5;` vs `a ? 0..10 : 0.5;`
      ~ technically none of these make sense
    ? can be used as stride in mem reading as uint8? `x = y[2:u8]`
  * `[0..20 |> _*0.5]`
    - verbose
    - messes up initial range
  * `0..20 += .01 : `
    - each member is increased by .01
  * `0..20 ~| 1`, `0..20 |~ 1`
  * ~~`[0..10 / 0.01]`~~
    + recommended by gpt
    - divides each item from range by 0.01
  * ~~`[0..10 + 0.01]`~~
    + compatible with range modifiers
    - can be confusable with `(0,1,2,3,4,...) + 0.01`
  * `[0..10 \ .5]`
    + makes use of `\` nicely
  * `[0..10 ++ .5]`
    - what about descending range?

## [x] Ranges: Range modifiers: -> any operators are range modifiers

  * `0..100 ** 0.01`
    * `a ~ 0..100 ** .01` - maps to pow range?
      + reinforces meaning of max operator, which is nice
    - pow each member

## [ ] Early return: how to consolidate type? -> just enforce f64 for now for early returns

  * we have to consolidate output type with early returns
  * cases:
  a. `(a?^b;c,d);`
  b. `(a?^12;13.4);`
  c. `(a?^12:^13.4;15)`

  1. we can simply upgrade preliminary returns to f64
    + simplest solution
    - enforces all funcs with prelim returns be f64
      ~+ prelim returns belong to userland anyways, it's not demanded internally
    - we can't

## [ ] Static variables / Functions: How can we call same fn with different context -> static var makes a clone `*clone=fn;clone()`

  * It seems for now to be able only externally
  ? but what if we need to say fill an array with signal from synth?

  1. `(a,b,c) <| x->osc(x)` - identifies state fn by callsite (literally location in code) - so `osc` is same state
    + same as tagged literals in js x`abc`
      - tagged literals don't account for callstack, they literally identify location in code
        * `x()=(*i=0); y()=x(); y();y();` - template tags would keep same state of x for different y calls.
          ? can we utilize that fact somehow?
            - not really: `sound()=(gen()); sound(); sound()` - 2 sound instances would share same gen instance, not good
    + logic similar to react hooks
    + solves problem of dynamic infinite linked list, so that we can know state tree in advance
    + we know all callsite ids in advance
    ? how can we iterate, say, 100 separate oscillators? having 100 callsites?
      ~+ kind-of meaningful reflection of underneath complexity
      ~+ musician would anyways manually connect such things, so it kind-of follows manual patching
    - doesn't leverage power of groups to deal with multiple states
      ~ js kind-of doesn't spawn template tags instances either
    ~ every function that has potential of calling internal state function becomes state function
    - not compatible with JS: we may need from JS a way to call same function multiple times with persistent state (expected)

  2. Indicator of static function, eg `*x() = (*i=0;...;i++)`
    + allows JS to use state persistency
    - doesn't solve direct case for JS: it still doesn't persist state

  4. Grops/ranges iterate as separate contexts, and lists as same context?
    `(a,b..c) <| item -> osc(item)` vs `samples <| sample -> osc(item)`
    - doesn't solve the problem of computed ranges: they still need dynamic-size instances
    - we may need to iterate list of frequencies via array...

  5. Parens indicate separate context or not, eg.
    * `(a,b,c)<|item->osc(item)` - same context
    * `(a,b,c)<|item->(osc(item))` - separate context
    * `(a,b,c)<|(item->osc(item))` - separate context
    - very fragile/sensitive: parens should not break the code
      - ie. parens are not "transparent" anymore
    - enforces syntax of stateful functions as
    + kind of meaningful if we define `*` context by `()` scope, not by function body
      + same way it works for declaring within-scope variables `(a;(b=0;))`
  5.1 (following 8.1 and 6.1) - scope defines state
    * `(osc()) + (osc()) + (osc())` - 3 separate oscillators
    * `osc() + osc() + osc()` - 3 calls to same oscillator
    * `(a,b,c)<|x->osc(x)` - same oscillator
    * `(a,b,c)<|(x->osc(x))` - same oscillator
    * `(a,b,c)<|x->(osc(x))` - separate oscillator
    + to export single instance to JS do `sin.`
    + to export separate instance to JS do `sin1()=(sin()); sin2()=(sin())`
    - loop meaning is confusable and unclear
    - makes parens super-sensitive - can't easily remove them

  6. `osc.0()`, `osc.1()` - use dot-operator to identify instances
    ? what about dynamic indexing

  6.1 `osc:0()`, `osc:1()`, `osc:i()`
    -~ `:` is reserved for labeling
    + different from dot access
  6.2 `osc#0()`, `osc#1()`, `osc#i()`
    + `#` used as id across many environments
    + `#` used as `member` naturally
    + looks like part of name, same time allows dynamic index
    ? subtle conflict with `list.1` or `list[1]` - what's meaning of `list#1`?
      - it means _first instance_ of `list`, but what's that?
    ? subtle conflict with potential strings `'abc{d}'` vs `osc{2}()`
      ~ `osc{2}` looks like multiple oscillators rather than osc identifier
    - isn't enough for absolute identification - osc can be called with same id somewhere else
    ~- needs resolution of automatic id and manual id, ie. we can't refer automatic ids manually eg `osc();osc#0()` - not the same.

    ~ `a#b` is means of polymorphism, but we resolve variables via scopes `(a=1) + (a=2)` are 2 different `a`'s.
      !? we could do the same for stateful functions: scope defines state

  7. Global functions are stateful, in-scope functions are per-call-context.
    * `sin(f);sin(f);sin(f);` - same state
    * `signal(f)=(sin(f)+sin(f*2)+sin(f*3);)` - separate states
    - code depends on nested level (non-transferable): not consistent
    - mind-wrapping: code behaves in different ways
    ? it seems by default we have to use same-state function, unless separate state is provided?

  8. All functions are single-state by default, unless instancing is provided via `osc#0() + osc#1() + osc#2() + osc#i()`
    + compatible with JS in external fn case
    + obvious separate instances
    + enables same-state and multi-state funcs: `fs |> (f,sum,i) -> sum+=osc#i(f)` vs `fs |> (f,sum,i) -> sum+=osc(f)`
    - cross-scope instance transparency: `osc(f); sound1(f)=(osc(f)+...); sound2(f)=(osc(f)+...)`
      -> these sounds use same osc instance.
      ? should osc instance depend on current scope?

  8.1 Per-scope (fn body) instance: `osc(); sound1(f)=(osc(f)+...); sound2(f)=(osc(f)+...)`
    + no osc id conflict
    ~ separate instances can be only-static as `osc.1(f) + osc.2(f) + osc.3(f)`
      + doesn't reserve `#` syntax
      + can be calculated in advance - no dynamic instances
        ~ likely we can prohibit `arr.1` - only for instances
      - natural expectation is `osc[i](f)` which we don't support
      - `a.b` associates more with "part of the whole", whereas `a#b` just identifies `a` by id
    ? how do we allow dynamic-sized scopes, ie. number of instances can vary?
      * number of instances is hardcoded/known in advance.
    * following 5.1:
      + if user needs a new instance - can wrap into new scope as `oscA()=(sin()+sin()+sin()...), oscB()=(sin()+sin()+sin())`
    + simple
    + easy to grasp: function is standalone instance, new instance is done either via wrapping or via new module instance
    + js-compatible
    + essentially same as 6.1/6.2: `sin1()=sin(); sin2()=sin(); ...` - just create as many funcs as you need with own names
    + parens don't affect scope anyhow
    - there's a chance of confusion when we may want a function have access to same context as root `sin();x()=(sin());`
      ? how to get access to root context? or just generally same fn context from another fn?
        ~ likely we can make functions strong singletons - whenever it's called from it gets same context
          ? same time how to create new instance then?
            !? `x()=(sin(x))` calls root instance, `*y()=(sin(x))` creates new instance?
              ? how to make mixed new and old instances then, eg. `y()=(*sin(a)+sin(b))`?
            !? you  an import global as `y()=(^sin;sin())`
            !? pass fn as arg: `x(sin1)=(sin()+sin1())` - keeps state of parent fn
              + we can pass fn refs as floats as well - it seems trivial to store all funcs in a table
                + that allows calling directly or indirectly

  9. Simple static vars: we have a function with single static context.

### [ ] Functions / Static variables: how to clone function? -> `x() = (*f1 = f);`

  1. Operator
    a. `a() = (*t=0;^t++); b = a;` - assignment creates fn instance.
    + assignment happens via global anyways
      + in global fn state has 0 value anyways
    - not intuitive that it copies instance rather than just creates reference
    b. `a() = (*t=0;^t++); *b = a;`
    - `*[a,a,a]` - no control over individual cloning instances
    c. `a() = (*t=0;^t++); b = *a;`, `[a, *a, a]`
    - conflict of `*` for static and `*` for new

  * We cannot have an operator for that, since it would imply runtime work, but static vars are created at static time - we can't randomly clone a function.

  2. `[12]a(x) = x*2; a[0](1)`
    + matches `[12]x = [1,2,3]`
      - introduces implicit type for `x`
    - number of instances can be figured out from eg. `a#5` call
    - if we import fn from other module, we cannot create multiple instances of it

  3. `(a,a1,a2)(x) = (...)`
    + organic way to create multiple instances
    + no new operators introduced
    - not clear how to instantiate imported fn multiple times
      ~+ we may want to limit dynamic imports/linking so that all fns are known static

  3.1. `a[10]() = (...); a.2()`
    + easiest way to define multiple instances
    - hints at `a[10];` syntax for initializing arrays - first array

  4. `c1 = c` - default assignment is clonable
    + we know that `c` is a function, not number (know its type)
      - not necessarily, if fn is passed as an argument
    + allows cloning imported fns
    - redefines meaning of `=` operator as literally just assigning
      ? do we ever need literal assignment?
        - yes, eg. `prev = cur; cur = new; cur(); cur = prev;`

  5. `c1 = clone(c)`
    - it is not runtime function
    - forces imports

  6. The `*f1 = f` operator clones a function
    + this is intention of `*f1` - to have local instance of generic fn
      + we almost never process code globally, I wonder what are these cases
    + this allows create clones as `f1(x) = (*_f=f;_f(x))` - like global vars locally defined
    - it doesn't immediately answer how to "reset" sound
    - limits to fn scope, confusing in case of global
      ~ we encourage to use fns, global instance is singleton

  7. No clone
    + explicit clone operator would imply dynamic cloning of arbitrary functions, which we don't support

### [ ] Functions / Static variables: How do we detect passed function as an argument? `f1(f) = (*_f=f; _f())`;

  1. By usage. If it is ever called - that's a function. If not - we don't care.
    - we cannot say if we should instantiate or not here: `f1(f) = (*clone=f; clone)`
  2. Type definition for args: `f1(a[], b, f()) = (*clone=f;clone)`
    + gentle types, feel natural & friendly
    + allows making vars something else but integers, with static-time checks
    - contrary to logic how we infer types
  3. Prohibit cloning callbacks
    -? how do we know if we're passing a function
  3.1 Limit init to only global vars
    + natural perf boost: no need to check for nan

  ? Do we need cloning callbacks and when? `x(cb) = (*clone = cb; clone())`

### [ ] Functions: how to "reset" sound, since one fn is once sound -> `f.t = 0`
  * Apparently there's difference of cloning a function and resetting a function

  1. `~f;`
    + we never need to ~ a function
    - we need to track types to know the difference
    + `~` means "refresh", "destroy"

  2. `*f;`
    - creates a clone intuitively

  3. `f.t = 0;`
    + meaningful: we anyways need special token to pass to a function
      + this just exposes internal state/param
    +
    - need to know private variables
    - cannot reset in full sense
    - conflicts with swizzles
    - fn name can be long `mySpecialSoundName.phase = 0`

## [ ] Static variables: logic - how to map callsite to memory address? -> ~~see implementation~~ - we use simple static vars

  ```
  sin(f, (; scope-id ;)) = (*phase=0;>phase+=f;...);
  note(f, (; parent ;)) = sin(f, (; parent,1 ;)) + (xxx ? sin(f*2, (; parent,2 ;))) + sin(f*3);
  chord(fs, (; parent ;)) = (fs) |> (f, sum, i) -> sum += note(f, (; parent,i ;)); ;; sum all freqs in a chord
  ;; likely will be this, to indicate separate callsites
  ;; chord(fs) = note(fs[0]) + note(fs[1]) + note(fs[2]) + note(fs[3]);
  ;; or this
  ;; chord(fs) = fs |> (f,sum,i) -> sum += note#i(f)
  samples |> (x,i) -> i<1000?chord(A,(;1;)) + i>1000?chord(B,(;2;)) + i>2000?chord(c,(;3;))
  ```

  * From the example - context is defined by # in current (function?) scope (like react hooks).
  * Unlike hooks, the id is defined by the # within function, not by call order.
  * Function scope prefixes the id

  1. For each stateful fn we create a global - current memory pointer;
    * upon calling the function, we set current pointer to proper address
    * outer calls should know all required memory for internal calls, since internal ptrs have offset within outer ptr

    ```
    sin.ptr, sin(f) = (phase=memory[sin.ptr];>phase+=f;...);
    note.ptr, note(f) = (sin.ptr=note.ptr; sin(f); sin.ptr+=sizeOf(sin)) + (sin(f*2)) ;
    chord.ptr, chord(fs) = (
      note.ptr = chord.ptr;
      fs |> (f, sum, i) -> (sum += note(f); note.ptr += sizeOf(note););
    )
    chord.ptr = 0 \or something like 0\;
    chord(A), chord.ptr += sizeOf(chord), chord(B), chord.ptr += sizeOf(chord), chord(C);
    ```
    * we know static size of a function state in advance, so we can just wrap calls to increase memory pointer to known size
      * so essentially we precalculate memory and "store" offsets as code constants
    - doesn't allow dynamic-size allocations
      ? can we store relative offsets, so that we don't need to know absolute addresses?
    + allows pre-allocating required memory for even gated stateful calls like `a ? note(a);`, meaning counting memory is done absolutely

  2. Count offsets from first fn to run
    ```
    sin(f, addr=mem) = (sin.count=0;*phase=(sin.count++;mem[addr]||0);>phase+=f;...);

    note(f, addr=mem) = (
      note.count=0
      sin(f, addr+note.count);(note.count+=sin.count) +
      (xxx ? sin(f*2, addr+note.count);(note.count+=sin.count)) +
      sin(f*3, addr+note.count);(note.count+=sin.count)
    );

    chord(fs, addr=mem) = (
      chord.count = 0
      fs |> (f, sum, i) -> (sum += note(f, addr+chord.count);chord.count+=note.count;);
    );

    root.count = 0;
    if (!addr) addr = mem
    chord(A,addr+root.count);root.count+=chord.count,
    chord(B,addr+root.count);root.count+=chord.count,
    chord(C,addr+root.count);root.count+=chord.count;
    ```
    - no address persistency: note can produce either 2 or 3 values
      ~ unless we unwrap all internal calls
        - order of calls still can be messed up, considering we can do loop: in other words we don't know order in advance
    * we don't know exact address offsets until we run the function, which can be gated. The only thing we know is call id.

  3. Local variable for callsites, eg `chord.123423` - once called they obtain the address.
    * similar to 1., but variables obtain the callsite address ptr dynamically, not hardcode
    ```
    sin.adr
    sin(f) = (*phase=0;>phase+=f;...);
    ;; this "table" stores all callsite instances addresses
    ;; would be meaningful to put into memory
    chord1.note1.sin1, chord1.note1.sin2, chord1.note1.sin3
    chord2.note1.sin1, chord2.note1.sin2, chord2.note1.sin3
    chord3.note1.sin1, chord3.note1.sin2, chord3.note1.sin3
    note.adr
    note(f) =
      (sin.adr=sin.1||=$mem;sin(f)) +
      (xxx ? (sin.adr=sin.2||=$mem;sin(f*2))) +
      (sin.adr=sin.3||=$mem;sin(f*3));
    chord.adr
    chord(fs) = fs |> (f, sum, i) -> sum += (note.adr=note.1||=$mem;note(f)); ;; sum all freqs in a chord
    chord1, chord2, chord3
    chord.adr=chord.1||=$mem;chord(A),
    chord.adr=chord.2||=$mem;chord(B),
    chord.adr=chord.3||=$mem;chord(C);
    ```
    - see chord function - it can receive any-length argument, but we can't create any-length number of variables
      -> callsite pointers must be stored in a table or linked list

  4. memory region for instances with static pointers
    + allows compactness - storing only addresses of data, since we know sequence of hooks in advance
    + allows dynamic allocation of new stateful functions
    + allows lazy-init of memory regions
    + allows storing absolute address value directly in code
    ```
    sin.adr
    sin(f) = (*phase=mem[adr]||(mem[adr]=alloc(1);...init);>>phase+=f;...;mem[adr]=phase;);
    note.adr
    note(f) = (
      (adr=mem[0x00];sin(f)) +
      (xxx?(adr=mem[0x01];sin(f*2))) +
      (adr=mem[0x02];sin(f*3))
    )
    chord(fs) = fs |> (f,sum,i) -> sum += (note(f));
    chord(A);
    chord(B);
    chord(C);
    ```
    - external variables is not flexible enough: we cannot dynamically spawn variables.
      * it's better to pass state as last argument, an array of arrays

  4.1 last argument is array of addresses for fn state
    + allows dynamic passing state to fn
    ```
    sin(f,st=[cur:1,..1]) = (*phase=mem[st[st.cur]||(mem[st[st.cur]]=[1])];st.cur++;...;mem[st[0]]=phase);
    note(f,st=[cur:1,..1]) = (sin(f,st) + (xxx?sin(f*2,st)) + sin(f*3,st); >>st.cur%=st.len);
    chord(fs,st=[cur:1,..1]) = (fx |> (f,sum,i) -> sum += note(f,st); >>st.cur%=st.len);
    chord(a); chord(b); chord(c);
    ```
    - gated params screw offset here - we need absolute offset instead of iterating.
  4.2
    + absolute offsets account for skipped positions
    ```
    sin(f,st=[..1],cur=0) = (*phase=mem[st[cur]||(mem[st[cur]]=1)];cur++;...;mem[st[cur]]=phase);
    note(f,st=[..(sizeof(sin)+sizeof(sin)+sizeof(sin))],cur=0) = (sin(f,st,cur) + (xxx?sin(f*2,st,cur+sizeof(sin)) + sin(f*3,st,cur+sizeof(sin)+sizeof(sin););
    chord(fs,st=[..sizeof(note)],cur=0) = (fs |> (f,sum,i) -> sum += note(f,st,cur+0));
    chord(a); chord(b); chord(c);
    ```

  5. fn scope-based instances entail C-like static variables per-function
    ```
    sin(f)=(*phase=0;...);
    x(f)=(sin(f)+sin(f)+cos(f));
    y(f) = (0..10|>(i,s)->x(i*108)+s + sin(54));

    ;; converts to

    sin.state = [..1];
    sin(f)=(phase=mem[sin.adr];...;st[sin.ptr]=phase);
    x.state = [..2];
    x(f)=(
      sin.prev=sin.state;sin.state=x.state.sub(0);
      cos.prev=cos.state;cos.state=x.state.sub(1);
      >>sin.state=sin.prev;
      >>cos.state=cos.prev;
      sin(f)+sin(f)+cos(f);
    )
    y.state = [..3];
    y(f)=(
      x.prev=x.state;x.state=y.state.sub(0);
      sin.prev=sin.state;sin.state=y.state.sub(3);
      >>x.state=x.prev;
      >>sin.state=sin.prev;
      0..10|>(i,s)->x(i*108)+s + sin(54)
    );
    ```
    + allows attaching/detaching all states in the beginning/end of parent function
    + doesn't require fake arguments
    + allows tracking function state in a standalone way

  6. fn.state holds ptr to fn state, fn.adr (current implementation)

  ```
    sin(f)=(*phase=0;...);
    x(f)=(sin(f)+sin(f)+cos(f));
    y(f) = (0..10 |> x(@*108) + sin(54));

    ;; converts to

    sin.state = malloc(1); \ alloc state for 1 variable
    sin(f)=(
      phase.ptr=mem[sin.state + 0] || malloc(1); \ load phase address or allocate if needed
      phase=mem[phate.ptr]; \ load value
      ...;
      mem[phase.ptr]=phase; \ save value
    );

    x.state = malloc(2)
    x(f)=(
      \ not sure if we need to save and restore prev state here:
      \ it's slower and it seems we're fine loading that directly
      sin.state=subarray(x.state, 0);
      cos.state=subarray(x.state, 1);
      sin(f)+sin(f)+cos(f);
    )

    y.state = malloc(3);
    y(f)=(
      x.state=subarray(y.state, 0);
      sin.state=subarray(y.state, 3);
      0..10 |> x(@*108) + sin(54)
    );
  ```

## [ ] Groups: Prohibit dynamic-size groups, make reflect stack ->

  + ~~Solves issue of state vars logic: we can precalculate addresses~~
  + ~~Likely we don't need heap: can be fully static memory~~
  + There's plenty of places where dynamic lists are not supported anyways: function return, function args
    + makes type known in advance
  + makes simple groups === stack
    + dynamic groups would force explicitly returning an array
  ~ maybe we need to introduce some meaningful static-only limitations for the beginning and get v1 of lang ready.
    * like array building, static-size map/reduce, static variables etc. once that's ready we may think of extending to dynamic-size ones.
  + we cannot dynamically declare local variables within loop. Static-size loop would make it possible to declare all variables in advance...
    - it would require thousands of local variables...
  * Likely loops generally won't need to produce output, except for list comprehension
  ? Is there cases when we need dynamic arrays?
    * `x() = (1..10)` - ranges can return v128 tokens

## [x] Loops: Loop vs fold: no difference -> ~~returns list <| or last |>~~ no difference, use `|>`

  * `sum=0; xs <| (x) -> (sum += x)`
  * `xs |> (x, sum) -> sum + x`
  * Folds seem to be more efficient than loops: they create single value as result, loop creates multiple values (heap?).

## [x] Loops: Alternative: merge `<|` and `|>` -> yes, we can just introduce single operator in context

  + this allows us to not know different kinds of loops
  + we anyways need a strategy to know if op result is required or not.
    + that makes sure extra optimization step (peephole) is not needed, which produces more compact & faster code
  + matches with `^` for current member
  * eg. `[a,b,c |> ^*2]` produces output list
  * `a,b,c |> ^*2;` doesn't have any stack output
  * `(a,b,c |> ^*2) + 1;` produces group
  + allows better precedence

## [x] Stdlib: pow -> compiled

  1. https://chromium.googlesource.com/external/github.com/WebAssembly/musl/+/landing-branch/src/math
    + musl, standard good impl
    - requires compiling to wasm
    - redundant
  2. https://github.com/jdh8/metallic/tree/master/src/math/double
    + what we need
    + minimal
  3. zig
  4. AssemblyScript + https://gist.github.com/stagas/d5de1a8dd82a397391caea31a4b75b3a
    + back via https://webassembly.github.io/wabt/demo/wasm2wat/
    - arbitrary memory addresses
  ...

  How to compile:
  ```
  clang --target=wasm32 -pipe -O3 -Wall -flto  -I path/to/include -c ./pow.c -o ./pow.o
  llvm-lto ./pow.o -o ./pow.wasm --exported-symbol=pow
  wasm2wat -f ./pow.wasm
  ```

## [x] Expose internal variables under `@` prefix? -> no, introduces reserved words and is unnecessary
  + `@memory[100]` defines memory of 100 members
    - reserved word
    + `@memory[10]` can read from memory
    + exports internal variable without need to customize config
    - can be declared via `[100]` (array disposes immediately but memory remains)
  + `@heap[100]` defines heap of 100 members
    - reserved word
    - can be customized via config
    - can be figured out from code
    - we don't track exact size, we measure in pages
  + `@` is current array member

## [x] Compiler: Static precompilation step -> yes
  + removes static checks
  + unrolls group operations
  + dedupes/denormalizes a * (b,c)
  + simplifies `=`
  + unwraps/normalizes brackets
  +? possibly optimizations for `(drop)`
  + `++`,`*=` ops
  +? ranges
  +? includes
  + static errors detection
  * everything that can be statically precalculated

## [x] Groups: `(a,b) ? (a,b)=h++` problem - what does it transform to? -> let's simply duplicate (most obvious)

  1. `(a ? a = h++, b ? b = h++)`
    - duplicates calculation
    + can actually be correct approach: loop also invokes rhs code multiple times
    + the most obvious
    -> let's do this

  2. `(a,b) ? (tmp=h++; a=tmp, b=tmp)`
    -? doesn't unroll obviously
    + intuitive (expected)

  3. `(a ? a = tmp ||= h++, b ? b = tmp ||= h++)`
    -~ duplicated code, but gated
    -? `tmp` is `0` by default, not sure how to make it `??=`

  4. `tmp=0/0; (a ? (tmp==nan?tmp=h++; a=tmp), b ? (tmp==nan?tmp=h++; b=tmp)`
    -~ duplicated code, but gated
    - extra condition per

## [x] Operators: should we introduce `??` and `??=` for init states -> nah

  -~ works on `nan` only: there's no `undefined` state
  -? should all undefined numbers become `nan`s?
  - discrepancy with JS: `NaN ?? 1` gives `NaN`

## [x] Compiler: should we make heap precompilable, rather than compilable? -> let's try tail-heap strategy

  * `@heap=[..1024], @heap.cur=0`
  + allows customizing heap via code
  + allows accessing heap as `@heap[10]`
  + allows customizing/accessing memory as `@memory=[..100]`
  + removes need in offsets math
  + heap is just address in memory, not some hardcoded low-level structure
  + heap can be dynamic (disposable) - eg. for temporary arrays etc.
    - if heap is after mem part, then nested dynamic arrays create too many memcpy ops
    + dynamic heaps extend nested memory limits

  ALT: not sure about precompilable, but we can allocate arrays at the tail (? of what)
    + end-allocation has worst-case same memory as max heap-size arrays would require
    + it doesn't require memcopy for flat dynamic arrays
    + it requires same or less amount of memcopy than head-heap would, since first layer is skipped

## [x] Operators: replace `&` with `/\` and `|` with `\/`? -> not clear what's xor

  *  `t*(((t>>12)|(t>>8))&(63&(t>>4)))` -> `t*(((t>>12)\/(t>>8))/\(63/\(t>>4)))`
  + makes use of font ligatures
  + frees | for pipes
  + frees & for something like topic holder
  - not clear what would be xor
    * `a><b`?
    * `a/\/b`?
    * `a/|\b`?
    * `a/!\b`?
  - `~` is still busy

## [ ] Operators: Linear regression from Julia x \ y

  ? what's that?

## [x] Loops: Replace `|>` with `|:` for loops? -> nah, let's keep `|>`

  1. `|:`
    + matches musical repeat block, which is very intuitive
    + reminds label a: ...
    + keeps body visually clean after bar, as if returning result, condition clarifies body: `[x*2]` ‚Üí `[x*2 |: x in 1..10]`
    + `|:` sounds like `|` such `:` that, swoooch th th
      + matches set builder `x++ |: x < 5` as `x++ such that x < 5`
    - it subtly conflicts with elvis operator `x in 1..10 ?: body`, but `x in 1..10 |: body`
      ~ we don't have elvis
    + `x * 2 |` is close intuition to standard list comprehension syntax
    + musically loop may have multiple ends and end mark `:|` place is uncertain, but `|:` is unambiguously at the beginning of loop.
    + refer to looping body, not condition, which is better by musical intuition
      - it disjoints condition from repeating part. In music |: denotes the beginning of loop, whereas here it stands in the middle.
    - does not stand as nice with parens `range |: (# + 1);`

    + it takes step away from associating `|>` with js pipes: it's not pipe.
    + has less to do with wrong assoc with `|>` etc.

    - `|:` is less obvious for pipes than `|>`, `out |>= gen() |> lp(#) |> amp(#)`
      ? `out |:= gen() :|: lp() :|: amp()`
        - not as nice for multiline
    - not convinced yet, way too fancy
    - no obvious way to write to destination
  2. `|>`
    + looks like play
    + indicates direction
    + allows vertical stacking
    - looks like pipe but has less to do with actual pipes
    - wrong operator sequence with loop `for i=0, i<len, i++`
    + allows directing output to range as `out[..] |> op(#) |> out[..]`
      ~ not necessary since can be done as `out[..] = out[..] |> op(#)` or `out[..] |>= op(#)`
    + gives flow feeling
  3. `<++`, `<=++`
    + matches operator sequence from loop
    - doesnt' work as pipe vertically
  4. `|<`, `|<=`
    + keeps pipe vertically
    - not nice to type due to autocomplete
  5. `->`, `=>`
    - no pipe feeling
    - confusable with fn definitions

## [x] Loops: Prohibit non-range operands for loops, `a |> x` means iterate over 1 element only -> yes

  + to iterate array always provide range or list `a[..] |> #`, `a, b, c |> #`
  + removes ambiguity from code and from brain

## [x] Conditions: Is `a ? b;` void or not? -> not void, like elvis a ?: b or a ? b : c

  * research was done somewhere here, but keyword "void" wasn't used, so to clarify
  + void: makes it direct, simple and different from `a && b`
  +? we have void operator also, do we? at least fns can return nothing, so
  - `a ? /b;` is not void
    ~ but return doesn't affect operator
  - same as elvis `a ?: b` is not void, this is not void
  - `/ a ? 1 : b ? 2;`
    ~- essentially `a ? b` means `a ? b : nan`

## [x] Loops: Write out operator `x[..] : a : b : x[..]` -> `x[..] |> a() |> b() |> x[..] = _`

  * we need it for copying loops or redirection, since `a = b` is not always the most useful
  1. `a..b -> x[..]`
  1.1 `a..b => x[..]`
    - conflict with arrow fns
  2. `a..b := x[..]`
    - reads as `a..b : a..b = x[..]`
  2.1 `a..b =: x[..]`
    - breaks end pipe alignment

## [x] Loops: `(x = (a, b..c[], d[e..] |> _*2) + f..g) |> x ? ^ : x+1` - how? -> see loop group iterations test

  1. rhs is dynamic function, generated code for the first sequence
    ```js
    const r = (v) => x ? break : x+1;
    let fgi = 0
    r(x=a+(f+fgi++));
    for (i = b; i < c; i++) r(i + fgi++);
    for (i = e; i < d[]; i++) r(double(d[i]) + fgi++);
    ```
    - creating unnecessary scope & exec context
    - each pipe operation creates a (macro) function in memory
    - no obvious way to break iteration

  2. rhs is loop, lhs is switch condition (or flattened generator function)
    - switch condition creates unnecessary check
      ~ that's minimal evil, and only for sequences
    + makes everything flat
    + supports break, skip
    ```js
    let g0i = 0, g01i, g02i, g1i = 0, g0, g1 // left group members & results
    while () {
      // 1. produce group results
      // FIXME: in subscript we optimized that by having an array of function checkers
      // (a, b..c[], d[e..] |> _*2) group
      // a
      if (g0i === 0) { g0 = a; g0i++; g01i = b; }
      // b..c[]
      else if (g0i === 1) { if (g01i < c[]) {g0 = g01i; g01i+=step} else g0i++, g02i = e; }
      // d[e..] |> _*2
      else if (g0i === 2) {
        g02 = d[g02i++]
        g1 = _ = g02*2
      }

      // f..g group
      if (g1i === 0) {  }

      // 1.1 calculate groups result
      _ = (x = g0 + g1)

      // 2. body
      x = x ? break : x+1

      // 3. write to stack, if needed
      stack.push(x)
    }
    ```

## [x] Assignment resolution `x = (1,2,3)` vs `x[1,2,3] = x[3,1,2]` - iterated (last item) vs saved/restored

  * first case is `(x=1; x=2; x=3)` - list is iterated in case of |> operator (else just last item)
  * second case needs resolution via stack or heap - list is saved (to heap/stack) and retreived

## [ ] Groups: Groups with ranges - are ops iterations or group mappers? -> ~~`=` is iterating operator~~ `= |>` is only iterating operator

  1. `x = (a,b..c)`
    * `x=a, x=b..c`
  2. `log(x = (a,b..c))`
    a. ~~calls multiple times? `log(x=a); log(x=b..c)`~~
    b. calls once with final argument `log(x=c)`
      ? makes `=` a uniquely iterating operator
        ~ it's already unique in assignment
        ~ not really - it returns lhs as signle arg
      - `(a,b..c) + 1` returns group
  3. `log((a,b..c))`
    * ~~calls as `log(a), log(b), log(...), log(c)`~~
      - that's inconsistent with `(a,b,c)` as items in stack
      - `x()=(a,b..c);log(x())` - makes `log` be called multiple times
      -? how to pass multiple args to a function as result of other function?
        * must be as simple as `y(x())`
          - but it contradicts calling as direct group `y((1,2,3))`
      -? how to get first output from result of a function `x()`?
        * ~~must be as simple as `x()[0]`~~
          - which is confusable with getting 0 item of each element in a group
        * ~~can be done as `x().0`~~
          - group is pop/push, not any index
        * ~~then `^x()`~~
          - not clear how to pick multiple
        * `(a,..)=x()`
    * passes group as args to call
      - it implies random-length args passed to fn
        ~ we can limit that possibility as `fn((a,b,c)=x())`
        ~ or we can implement dynamic args

### [x] Groups: ~~Get element of group~~ - can get only head of stack, but see pick below

  * Suppose `x()` returns multiple elements, so we have groups as elements on stack

  1. `(a,b)[0]`
    - `a[0],b[0]`
  2. `(a,b).1`
    ~- can be confused with `a.1,b.2`
      ~+ less so, since `.1` looks a bit more part of name
    - mb a bit too heavy load on `.` - it already means a lot everywhere
      ~+ `.` has to do with iterators/groups anyways
    - introduces syntax layer, which is not good
  3. `(a,b)#1`

  * Since group deals with stack/heap, we cannot get arbitrary item, it is pop/push mechanics.

### [ ] Groups: How to pop/pick from group? -> `a.. = x()`

  * See above: what if we need to get first element of returned group from `x()`?

  1. `(a,b)>>;(a,b)<<1`
    - `(a<<1,b<<1)`
  2. `^(a,b,c) === a`
    + regex does that
    + that means arrow up operator
    - not clear how to pick multiple
  3. `(a,b,c..) = d`
    - contradicts to js
    + logical
  4. `(a,b) = (c,d,e)`
    + matches JS
    - blocks loops
    - conflicts with meaning of groups
  5. `a = (b,c,d)` as JS, but `(a = (b,c,d)) |> a` as loop
    + covers JS style
    + covers loops
    - at odds with group ops like `a + (b,c,d)`

### [ ] Loops: `=` and `|>` precedence

  1. `a=b |> c`
    - unlike JS
  2. `a = b|>c`
    + js-like
    + organic for source rewrite
      - we may not need full source rewrite
    - forces iteration variable to be wrapped `a = (i = b) |> c`
    ?- but since `i` is defined within isolated scope, it's not accessible for `c`
      ~+ nah, `i` is defined per-fn scope, not inside, so all good, no need to wrap

## [ ] Errors: shortness or specificity?
  + Specificity allows better identifying
  - It bloats the size

## [x] Function return: type conciliation -> try upgrading return types/lengths

  1. Enforce explicit syntax consistency
    + consistent syntax `f()=(a?/1.0,0.0;b?/2.0,3.0;4.1,0.0)`
    - `f()=(a?/1; b?/2.)` throws error
      - can be annoying fixing declarations all around

  2. Autoconciliation
    + permits `f()=(a?/1;b?/2,3;4.1)`
      ~- creates wrong expectation from function as if it has varied return
      * int/float must be only implicit optimization, not UI thing
    + no need to search for all returns
    + that's the principle of language
    - can be unpredictable: changing main return changes all prev returns by default
      ~+ ugrade is relatively safe and anticipated: just numbers to numbers, max length of outputs
      + allows to shorten code, eg. `f() = (a?/; 1,2,3)` would just bail out null case meaningfully
    - less efficient due to double scan
      ~+ no need to double scan
    - not clear how to do it, since we may track variables
      ? generate syntax tree instead of strings
      ~+ can produce strings with `$<return>` fields that are replaced after fn body with conciliated type conversion
    - not sure if we can upgrade multiple elements in stack: we can easily upgrade the last one, but multiple?
      ~ we can eg. allow ints only for single-item output
      ~+ ok, we create as many temp variables per function as many items in stack are there and form proper output, that's extra write/read operation for inconsistent return
    ? length we can also upgrade, considering some dynamic loops can have varied output size

  3. Force float for fn output
    + fn args are float-only anyways
      - should not be the case
        ~ eg. can be args type can be figured out from defaults
    - not nice to pay with performance for syntax sugar

## [x] Approximately operator `a =~ 10` -> no
  + fira converts to ~~
  - `a = ~10`

## [ ] Function: !Automemoize function so that the following runs read from memory

## [ ] Static variables: do we ever need it?

  + allows defining per-fn state
    - entails cloning arbitrary fn state, which entails memory use for fns, which is better to be avoided
  - it seems we're trying to define per-function state to avoid clash of multiple sounds
    - instead, we could focus on describing sound well in very familiar and intuitive way and just include other sounds
    - each sound this way would naturally have its own scope: stateful would become globals
  - params like `t` can be just global vars
    - it allows easily sharing state between multiple functions
      - we likely would need sharing that state anyways
    - it is shortest syntax: no new operators `*`, symbols `#`, prefixes `fn.t`
    - resetting state is super-obvious, just `t=0`
      + each sound would imply its own explicit global variable: just creates name collision
  + multiple sounds may have each one its own internal state
    + eg. global age of the universe and local age of each individual
  + initially that was `useState` idiom - state per component
    + reset makes it look like object `a = (*x=1;); a.x = 2;`

### [ ] Static variables: get rid of ->

  * it seems we're trying to define per-function state via static variables to avoid clash of multiple sounds
  * instead, we could focus on describing sound well in very familiar and intuitive way in one file and wrap it as module
  + each sound this way would naturally have its own scope: static would become globals
    - state for a fn is pretty natural as well
  + sound descriptors would become tiny copy-pasteable formulas
    - they are still tiny with stateful
  + sound fragments can be URL parts
    !+ it can be even inlined completely
    !+ compiler can take handle of fetching URLs, if imports are by URLs
    - doesn't implicate state vars, it can still be copy-pasteable
  + it makes code less intimidating: reduced amount of new stuff, just plain expectation
  + it solves problem of fn argument type: we don't need to clone functions as static anymore
    - we still have to clone functions somehow even if they're external
  + it would make compiler / parser code less intimidating
    - except for import/instantiation
  + modularization allows easier fns memoization
    - we can memoize regardless
  ? what would import look like then, with fn instantiation?

## [ ] Alternative: Porffor -> likely not: different priority

  + For web-audio-api we can get started already
    + It will be more solid, familiar choice, with shared codebase
  + For metronome we can get started/prototype with existing floatbeater
  + For bytebeats we don't need to recompile anything into piezo - just have a collection
  + Porforr is way ahead already for basic things
    + Porforr has good pace/traction
    + Porforr has growing community, can become a big thing
  + Piezo gets stuck over basics: it aims at problems in so many directions, from syntax to compilation logic
    + Porforr just improves on existing JS base with cool proposals
  + Porforr is fast enough for live coding
  + It already has 2c compiler for embeddeds
  + With piezo it will take years to build strong foundation
    + Anyone from JS land will struggle understanding the base, despite shared syntax
  + Porf is supported by immense existing JS ecosystem
  + Porf is a great deal of delegation of secondary tasks: focus on sound well instead of compiler

  - porf is very experimental
    - changes every 10 mins
  - there's no proof of future stable version, it can stall halfway
    - it gives no guarantees if wasm will work
  - there's risk of including too much and bloating wasms
    - it's already heavy
    - it's too heavy for live env compile
  - no ranges, no units, no groups, no multiple values, no pipe, no defer, no inits/exports
    - a bunch of keywords, implicits
    - objects, promises, regexes and other unnecessary structures
  - JS keeps bloating
  - code is less compact
  - possible risk of runtime
  - it's way less familiar
  - it has way less control
  - it is already slower than piezo
    - the parsing is expecially dirty
  - some solutions look super-unoptimal (arrays storage)
  - one of big points for web-audio-api was to test piezo, not vice-versa
  - it doesn't have clear type conversion / tracking
  -? not sure if it will allow bytebeats

  * let's consider projections

  1. Piezo
    + Unique niche language with variety of niche cases
    + Easier to search code pieces in tight ecosystem
    + More limited & focused syntax
    + Fastest in class parsing / syntax deals
    + Minimally meaningful output
    + Independent of all that nonsense (in potential - absolutely)
    + It can be compiled to porfor, c, anywhere
    - Less adoption
    - Slower growth rate
    - Embedding can be very far
    - No standard test base

  2. Porffor
    + Compatible, reliable, WASI-enabled JS compiler to WASM
    - Heavier than piezo, in all aspects: codebase, produced wasm, runtime
      - It aims for 262 compatibility, which is redundancy of its own
    + High credibility due to standardized test base
    - Writing JS for binary code is lame-ish

## [ ] Mixing fn / object / array

  a. We want to have arrays as objects `a = [x:1, y:2]; a.x = 2`
  b. We see state vars as objects `f() = (.x=1,.y=2;); f.x = 2`
  c. Positional statements have meaning in `for (init; before; after) {}`

## [ ] Functions: anonymous functions?

+ they allow avoiding state variables: scope mechanism naturally defines "instance"
```
Sine = f -> (
  phase=0;
  () -> (phase++; sin(phase))
)
sine = Sine()
```
  - that doesn't help resolving name, since we may want to do case-agnostic
+ they allow creating hash/dict
```
let gen = [
  sin: f -> (p, () -> ()),
  cos: f -> (p, () -> ())
]
```
  - that creates potential for infinite functional recursion, which is hell: we only need 2 levels
+ that creates difficulty figuring out type of input argument, since that can be a function
